package nl.dpdk.collections.graphs {	import nl.dpdk.collections.CollectionTest;	import nl.dpdk.collections.graphs.utils.BreadthFirstSearch;	import nl.dpdk.collections.graphs.utils.ConnectedComponents;	import nl.dpdk.collections.graphs.utils.GraphDegree;	import nl.dpdk.collections.graphs.utils.IGraphVisitor;	import nl.dpdk.collections.lists.List;	import nl.dpdk.debug.RunTimer;	
	public class GraphTest extends CollectionTest {		private var instance : Graph;				/**		 * constructor		 */		public function GraphTest(testMethod : String = null) {			super(testMethod);		}				public function reset(directed: Boolean = true):void{			instance = new Graph("test graph", directed);			}				public function testSimpleStuff() : void {			trace("GraphTest.testSimpleStuff()");			reset(true);			instance.add("a");				instance.add("b");				instance.add("c");							instance.add("d");				instance.add("e");				assertEquals(instance.size(), 5);			assertEquals(instance.isEmpty(), false);			assertEquals(instance.remove("jojo"), false);			assertEquals(instance.remove("e"), true);			assertEquals(instance.size(), 4);			instance.clear();			assertEquals(instance.size(), 0);			assertEquals(instance.isEmpty(), true);			assertEquals(instance.remove("jojo"), false);			assertEquals(instance.remove("e"), false);			assertEquals(instance.remove("a"), false);			assertEquals(instance.size(), 0);			assertEquals(instance.isEmpty(), true);		}				public function testGraphNodes() : void {			trace("GraphTest.testGraphNodes()");			reset(true);			var node : GraphNode;			var otherNode : GraphNode;						node = new GraphNode("a");			otherNode = new GraphNode("x");			assertEquals(node.getData(), "a");				assertEquals(node.getAdjacencyList().size(), 0);			node.clear();				assertEquals(node.getData(), null);				node.setData("b");			assertEquals(node.getData(), "b");							//because we're in the same package, we can test the internal methods			assertEquals(node.getOutDegree(), 0);			assertEquals(node.getAdjacencyList().size(), 0);			assertEquals(node.getEdgeList().size(), 0);						node.addEdge(otherNode, 2);			assertEquals(node.getOutDegree(), 1);			assertEquals(node.getAdjacencyList().size(), 1);			assertEquals(node.getEdgeList().size(), 1);						//no duplicate, alter weight only			node.addEdge(otherNode, 3);			assertEquals(node.getOutDegree(), 1);			assertEquals(node.getAdjacencyList().size(), 1);			assertEquals(node.getEdgeList().size(), 1);						//remove node			assertFalse('cannot remove edge to myself', node.removeEdge(node));			assertTrue(node.removeEdge(otherNode));						//clear the node			node.clear();			assertEquals(node.hasEdges(), false);			assertEquals(node.getData(), null);						node.setData("a");			assertFalse(node.removeEdge(new GraphNode("nonexistent")));			assertFalse(node.getAdjacencyList().size() != 0);		}		public function testGraphEdges() : void {			trace("GraphTest.testGraphEdges()");			reset(true);				var node : GraphNode;			var otherNode : GraphNode;			var edge : GraphEdge;			var otherEdge : GraphEdge;						//two testnodes			node = new GraphNode("a");			otherNode = new GraphNode("x");			//two test edges			edge = new GraphEdge(otherNode);			otherEdge = new GraphEdge(node);						//check weight validation and changing			assertEquals(edge.getWeight(), GraphEdge.WEIGHT_NORMAL);			assertEquals(otherEdge.getWeight(), GraphEdge.WEIGHT_NORMAL);			edge.setWeight(2);			assertEquals(edge.getWeight(), 2);			edge.setWeight(-1);			assertEquals(edge.getWeight(), 0);			//not changed			assertEquals(otherEdge.getWeight(), GraphEdge.WEIGHT_NORMAL);			edge.setWeight(GraphEdge.WEIGHT_NORMAL);			assertEquals(edge.getWeight(), GraphEdge.WEIGHT_NORMAL);						//check edges			assertSame(edge.getNode(), otherNode);			assertSame(otherEdge.getNode(), node);			assertEquals(node.getOutDegree(), 0);						//add edge on node			node.addEdge(otherNode, GraphEdge.WEIGHT_NORMAL);			assertNotSame(node.getEdge(otherNode), edge);			assertEquals(node.getOutDegree(), 1);			//no edge to self			node.addEdge(node, GraphEdge.WEIGHT_NORMAL);			assertEquals(node.getOutDegree(), 1);			//check weight			assertEquals(node.getEdge(otherNode).getWeight(), GraphEdge.WEIGHT_NORMAL);			//cneck node on edge			assertSame(node.getEdge(otherNode).getNode(), otherNode);			//change weight			node.addEdge(otherNode, 3);			assertEquals(node.getOutDegree(), 1);			assertEquals(node.getEdge(otherNode).getWeight(), 3);						//check adjacent nodes and edges			assertEquals(node.getAdjacencyList().get(0), otherNode);			assertEquals(GraphEdge(node.getEdgeList().get(0)).getNode(), otherNode);			assertEquals(node.getAdjacencyList().size(), 1);			assertEquals(node.getEdgeList().size(), 1);									//do some removal			assertFalse(node.removeEdge(new GraphNode("z")));			assertTrue(node.removeEdge(otherNode));			assertNull(node.getAdjacencyList().get(0));			assertNull(GraphEdge(node.getEdgeList().get(0)));			assertEquals(node.getAdjacencyList().size(), 0);			assertEquals(node.getEdgeList().size(), 0);									assertEquals(node.getData(), "a");			node.clear();			assertEquals(node.getData(), null);			assertEquals(node.getOutDegree(), 0);			assertEquals(node.getEdgeList().size(), 0);			assertEquals(node.getAdjacencyList().size(), 0);		}				public function testConnectedComponents() : void {			trace("GraphTest.testConnectedComponents(): undirected graphs only");			reset(false);						instance.add("a");			instance.add("b");			var cc : ConnectedComponents;			cc = new ConnectedComponents(instance);			assertEquals(cc.getConnectionCount(), 2);			//add third node			instance.add("c");			cc = new ConnectedComponents(instance);			assertEquals(cc.getConnectionCount(), 3);			assertEquals(cc.getConnected(instance.get(0), instance.get(1)), false);			assertEquals(cc.getConnected(instance.get(1), instance.get(2)), false);			//add edge, to reduce seperate componeents			instance.addEdge(instance.get(0), instance.get(1));			cc = new ConnectedComponents(instance);			assertEquals(cc.getConnectionCount(), 2);			assertEquals(cc.getConnected(instance.get(0), instance.get(1)), true);			assertEquals(cc.getConnected(instance.get(1), instance.get(2)), false);			//connect them all			instance.addEdge(instance.get(1), instance.get(2));			cc = new ConnectedComponents(instance);			assertEquals(cc.getConnectionCount(), 1);			assertEquals(cc.getConnected(instance.get(0), instance.get(1)), true);			assertEquals(cc.getConnected(instance.get(1), instance.get(2)), true);			//empty instance			instance.clear();			cc = new ConnectedComponents(instance);			assertEquals(cc.getConnectionCount(), 0);			assertEquals(instance.size(), 0);			assertEquals('testing null values for connection', cc.getConnected(instance.get(0), instance.get(1)), false);						//check on directed graph			reset(true);			instance.add("a");			instance.add("b");			cc = new ConnectedComponents(instance);			assertEquals(cc.getConnectionCount(), 0);		}				public function testAddRemoveContainsGetSet() : void {			trace("GraphTest.testAddRemoveContainsGetSet()");				reset(true);			var a : GraphNode = new GraphNode("a");			var b : GraphNode = new GraphNode("b");			var c : GraphNode = new GraphNode("c");			var d : GraphNode = new GraphNode("d");			var e : GraphNode = new GraphNode("e");			var x : GraphNode = new GraphNode("x");			instance.add(a);			instance.add(b);			instance.add(c);			instance.add(d);			instance.add(e);						assertEquals("a at 0", instance.getNodeIndex(a), 0);			assertEquals("b at 1", instance.getNodeIndex(b), 1);			assertEquals("c at 2", instance.getNodeIndex(c), 2);			assertEquals("d at 3", instance.getNodeIndex(d), 3);			assertEquals("e at 4", instance.getNodeIndex(e), 4);			assertEquals("no node index for nonexistent", instance.getNodeIndex(new GraphNode("nonexistent")), -1);			assertFalse("does not contain another", instance.contains(new GraphNode('anotherone')));			assertEquals("size is 5", instance.size(), 5);						//remove a node			assertTrue(instance.remove(c));			assertEquals(instance.getNodeIndex(a), 0);			assertEquals(instance.getNodeIndex(b), 1);			assertEquals(instance.getNodeIndex(c), -1);			assertEquals(instance.getNodeIndex(d), 2);			assertEquals(instance.getNodeIndex(e), 3);			assertEquals(instance.getNodeIndex(new GraphNode("nonexistent")), -1);			assertFalse(instance.contains(new GraphNode('anotherone')));			assertFalse("c has been removed", instance.contains(c));			assertEquals(instance.size(), 4);						//remove a removed node			assertFalse(instance.remove(c));			assertEquals(instance.getNodeIndex(a), 0);			assertEquals(instance.getNodeIndex(b), 1);			assertEquals(instance.getNodeIndex(c), -1);			assertEquals(instance.getNodeIndex(d), 2);			assertEquals(instance.getNodeIndex(e), 3);			assertEquals(instance.getNodeIndex(new GraphNode("nonexistent")), -1);			assertFalse(instance.contains(new GraphNode('anotherone')));			assertFalse("c has been removed", instance.contains(c));			assertEquals(instance.size(), 4);						//remove a node			assertTrue(instance.remove(e));			assertEquals(instance.getNodeIndex(a), 0);			assertEquals(instance.getNodeIndex(b), 1);			assertEquals(instance.getNodeIndex(c), -1);			assertEquals(instance.getNodeIndex(d), 2);			assertEquals(instance.getNodeIndex(e), -1);			assertFalse("e has been removed", instance.contains(e));			assertEquals(instance.size(), 3);						//remove a removed node			assertFalse(instance.remove(e));			assertEquals(instance.getNodeIndex(a), 0);			assertEquals(instance.getNodeIndex(b), 1);			assertEquals(instance.getNodeIndex(c), -1);			assertEquals(instance.getNodeIndex(d), 2);			assertEquals(instance.getNodeIndex(e), -1);			assertFalse("c has been removed", instance.contains(c));			assertFalse("e has been removed", instance.contains(e));			assertTrue("a has not been removed", instance.contains(a));			assertTrue("b has not been removed", instance.contains(b));			assertTrue("d has not been removed", instance.contains(d));			assertEquals(instance.size(), 3);						//remove a node			assertTrue(instance.remove(a));			assertEquals(instance.getNodeIndex(a), -1);			assertEquals(instance.getNodeIndex(b), 0);			assertEquals(instance.getNodeIndex(c), -1);			assertEquals(instance.getNodeIndex(d), 1);			assertEquals(instance.getNodeIndex(e), -1);			assertFalse("c has been removed", instance.contains(c));			assertFalse("e has been removed", instance.contains(e));			assertFalse("a has been removed", instance.contains(a));			assertTrue("b has not been removed", instance.contains(b));			assertTrue("d has not been removed", instance.contains(d));			assertEquals(instance.size(), 2);						//now add a back again			instance.add(a);			assertEquals(instance.getNodeIndex(a), 2);			assertEquals(instance.getNodeIndex(b), 0);			assertEquals(instance.getNodeIndex(c), -1);			assertEquals(instance.getNodeIndex(d), 1);			assertEquals(instance.getNodeIndex(e), -1);			assertFalse("c has been removed", instance.contains(c));			assertFalse("e has been removed", instance.contains(e));			assertTrue("a has been added again", instance.contains(a));			assertTrue("b has not been removed", instance.contains(b));			assertTrue("d has not been removed", instance.contains(d));			assertEquals(instance.size(), 3);						//remove a node			assertTrue(instance.remove(d));			assertEquals(instance.getNodeIndex(a), 1);			assertEquals(instance.getNodeIndex(b), 0);			assertEquals(instance.getNodeIndex(c), -1);			assertEquals(instance.getNodeIndex(d), -1);			assertEquals(instance.getNodeIndex(e), -1);			assertFalse("c has been removed", instance.contains(c));			assertFalse("c has been removed", instance.contains("c"));			assertFalse("e has been removed", instance.contains(e));			assertFalse("e has been removed", instance.contains("e"));			assertTrue("a has not been removed", instance.contains(a));			assertTrue("a has not been removed", instance.contains("a"));			assertTrue("b has not been removed", instance.contains(b));			assertTrue("b has not been removed", instance.contains("b"));			assertFalse("d has  been removed", instance.contains(d));			assertFalse("d has  been removed", instance.contains("d"));			assertEquals(instance.size(), 2);						//remove all			assertTrue(instance.remove(b));			assertFalse(instance.remove(d));			assertTrue(instance.remove(a));			assertFalse(instance.contains(a));			assertFalse(instance.contains(b));			assertFalse(instance.contains(c));			assertFalse(instance.contains(d));			assertFalse(instance.contains(e));			assertEquals(instance.size(), 0);									//add new and check contains with node reference and data reference			instance.add(a);			instance.add(b);			instance.add(c);			instance.add(d);			instance.add(e);			instance.add(new GraphNode("nonexistent"));			assertTrue(instance.contains(a));			assertTrue(instance.contains("a"));			assertTrue(instance.contains(b));			assertTrue(instance.contains("b"));			assertTrue(instance.contains(c));			assertTrue(instance.contains("c"));			assertTrue(instance.contains(d));			assertTrue(instance.contains("d"));			assertTrue(instance.contains(e));			assertTrue(instance.contains("e"));			assertTrue(instance.contains("nonexistent"));			assertFalse(instance.contains("bogus"));			assertEquals(instance.size(), 6);									//do some setting stuff after this			instance.set(0, x);			assertFalse(instance.contains(a));			assertTrue(instance.contains(x));			assertEquals('x has been placed at 0', instance.getNodeIndex(x), 0);			assertEquals('a was overwritten', instance.getNodeIndex(a), -1);			assertEquals(instance.size(), 6);						//out of bounds insertion of node			instance.set(100, a);			assertTrue(instance.contains(a));			assertTrue(instance.contains(x));			assertEquals('x has been placed at 0', instance.getNodeIndex(x), 0);			assertEquals('a was added instead of set, after nonexistent node', instance.getNodeIndex(a), 6);			assertEquals(instance.size(), 7);									//cannot overwrite if node is already in graph!			instance.set(0, b);			assertEquals(instance.getNodeIndex(a), 6);			assertEquals(instance.getNodeIndex(b), 1);			assertEquals(instance.size(), 7);			assertEquals(instance.getNodeIndex(x), 0);						//out of bounds insertion of normal data			instance.set(100, 'yehaaw');			assertEquals(instance.size(), 8);			assertEquals(instance.get(7).getData(), 'yehaaw');			//same data, but different node will be created			instance.set(100, 'yehaaw');			assertEquals(instance.size(), 9);			assertEquals(instance.get(7).getData(), 'yehaaw');			assertEquals(instance.get(8).getData(), 'yehaaw');			assertNotSame(instance.get(8), instance.get(9));						//nonexistent indexes			assertNull(instance.get(100));			assertNull(instance.get(-1));		}		public function testEmptySizeClear() : void {			trace("GraphTest.testEmptySizeClear()");			reset(true);			assertEquals(instance.size(), 0);				assertTrue(instance.isEmpty());				assertFalse(instance.contains("a"));						instance.add("a");			assertEquals(instance.size(), 1);				assertFalse(instance.isEmpty());				assertTrue(instance.contains("a"));			instance.clear();			assertEquals(instance.size(), 0);				assertTrue(instance.isEmpty());				assertFalse(instance.contains("a"));			//check variations in node adding and simple data adding			instance.clear();			var node : GraphNode = new GraphNode("a");			var otherNode : GraphNode = new GraphNode("b");			instance.add(node);			assertEquals(instance.size(), 1);				assertFalse(instance.isEmpty());				assertTrue(instance.contains("a"));			assertTrue(instance.contains(node));			assertFalse(instance.contains(otherNode));			assertFalse(instance.contains("b"));			instance.add("b");			assertTrue(instance.contains("b"));			assertFalse(instance.contains(otherNode));		}				public function testBreadthFirstAndDegree() : void {			trace("GraphTest.testBreadthFirstAndDegree()");			reset(true);			instance.add("a");			instance.add("b");			instance.add("c");			instance.add("d");			instance.add("e");						var visitor : GraphNodeVisitor; 						visitor = new GraphNodeVisitor();			instance.breadthFirst(instance.get(0), visitor);			assertEquals(GraphNode(visitor.visited.get(0)).getData(), "a");			assertEquals(visitor.visited.size(), 1);						visitor = new GraphNodeVisitor();			instance.breadthFirst(instance.get(1), visitor);			assertEquals(GraphNode(visitor.visited.get(0)).getData(), "b");			assertEquals(visitor.visited.size(), 1);						instance.addEdge(instance.get(0), instance.get(1));			//a-b						instance.addEdge(instance.get(1), instance.get(2));			//b-c						instance.addEdge(instance.get(2), instance.get(1));			//c-b						instance.addEdge(instance.get(2), instance.get(0));			//c-a				//seperate component			instance.addEdge(instance.get(3), instance.get(4));			//d-e				assertEquals(GraphNode(instance.get(0)).getOutDegree(), 1);					assertEquals(GraphNode(instance.get(4)).getOutDegree(), 0);					assertEquals(GraphNode(instance.get(3)).getOutDegree(), 1);					assertEquals(GraphNode(instance.get(2)).getOutDegree(), 2);											//start at "a" -- only a-b-c			visitor = new GraphNodeVisitor();			instance.breadthFirst(instance.get(0), visitor);			assertEquals(visitor.visited.size(), 3);						//start at 'e' -- only d-e, so NO e to d			visitor = new GraphNodeVisitor();			assertEquals(GraphNode(instance.get(4)).getOutDegree(), 0);					assertEquals(GraphNode(instance.get(3)).getOutDegree(), 1);					instance.breadthFirst(instance.get(4), visitor);			assertEquals('d connected to e', visitor.visited.size(), 1);			instance.addEdge(instance.get(4), instance.get(3));			//e-d			assertEquals(GraphNode(instance.get(4)).getOutDegree(), 1);					assertEquals(GraphNode(instance.get(3)).getOutDegree(), 1);					//start at 'e' -- e-d and d-e			visitor = new GraphNodeVisitor();			instance.breadthFirst(instance.get(4), visitor);			assertEquals('d and e fully connected', visitor.visited.size(), 2);												instance.addEdge(instance.get(0), instance.get(3));			//a-d						instance.addEdge(instance.get(2), instance.get(4));			//c-e						visitor = new GraphNodeVisitor();			assertEquals(instance.size(), 5);			instance.breadthFirst(instance.get(0), visitor);			//trace(visitor.visited.toArray().toString());			assertEquals('visit all nodes', visitor.visited.size(), 5);		}		public function testDenseGraphTraversal() : void {			trace("GraphTest.testDenseGraphTraversal(): df and bf");			reset(true);			var size : int = 100;			var node : GraphNode;			var edge : GraphEdge;						//build the nodes			RunTimer.start();			for(var i : int = 0;i < size;++i) {				instance.add(Math.random() * 10000000);			}			RunTimer.traceRunTime("added graph nodes: " + size, true);			RunTimer.start();			//connect all nodes to all edges, totally undirected, dense graph			for(i = 0;i < instance.size();++i) {				for(var j : int = 0;j < instance.size();++j) {					instance.addEdge(instance.get(i), instance.get(j));					}			}			RunTimer.traceRunTime("connected all nodes with edges: " + size, true);						//check all nodes connected			assertEquals(instance.size(), size);			assertEquals(instance.getInDegree(instance.get(1)), size - 1);			assertEquals(instance.getOutDegree(instance.get(1)), size - 1);			assertEquals(instance.getInDegree(instance.get(Math.round(size / 2))), size - 1);			assertEquals(instance.getOutDegree(instance.get(Math.round(size / 2))), size - 1);			assertEquals(instance.getInDegree(instance.get(size - 1)), size - 1);			assertEquals(instance.getOutDegree(instance.get(size - 1)), size - 1);									var visitor : GraphNodeVisitor; 						//depthfirst			visitor = new GraphNodeVisitor();			RunTimer.start();			instance.depthFirst(instance.get(0), visitor);			RunTimer.traceRunTime("depthFirst: " + size, true);			assertEquals(visitor.visited.size(), size);						//out of bounds, null reference			visitor = new GraphNodeVisitor();			instance.depthFirst(instance.get(instance.size()), visitor);			assertEquals(visitor.visited.size(), 0);									//breadthfirst			visitor = new GraphNodeVisitor();			RunTimer.start();			instance.breadthFirst(instance.get(0), visitor);			RunTimer.traceRunTime("breadthFirst: " + size, true);			assertEquals(visitor.visited.size(), size);						//out of bounds, null reference			visitor = new GraphNodeVisitor();			instance.breadthFirst(instance.get(instance.size()), visitor);			assertEquals(visitor.visited.size(), 0);						//connection stats//			RunTimer.start();//			var cc : ConnectedComponents = new ConnectedComponents(instance);//			RunTimer.traceRunTime("check create connection of graph: " + size, true);//			assertEquals(cc.getConnectionCount(), 1);//			RunTimer.start();//			assertEquals(cc.getConnected(instance.get(1), instance.get(size - 1)), true);//			assertEquals(cc.getConnected(instance.get(1), instance.get(Math.round(size / 2))), true);//			assertEquals(cc.getConnected(instance.get(size - 2), instance.get(size - 1)), true);//			assertEquals(cc.getConnected(instance.get(size - 2), instance.get(Math.round(size / 2))), true);//			assertEquals(cc.getConnected(instance.get(Math.floor(Math.random() * size)), instance.get(size - 1)), true);//			assertEquals(cc.getConnected(instance.get(Math.floor(Math.random() * size)), instance.get(Math.round(size / 2))), true);//			RunTimer.traceRunTime("diverse connection queries: " + size, true);									//breadthfirst			var stopVisitor : GraphNodeVisitorFiveOnly = new GraphNodeVisitorFiveOnly();			RunTimer.start();			instance.breadthFirst(instance.get(0), stopVisitor);			RunTimer.traceRunTime("breadthFirst five only: " + size, true);			assertEquals("breadthfirst visitor five only", stopVisitor.visited.size(), 5);						//breadthfirst			stopVisitor = new GraphNodeVisitorFiveOnly();			RunTimer.start();			instance.depthFirst(instance.get(0), stopVisitor);			RunTimer.traceRunTime("breadthFirst five only: " + size, true);			assertEquals("depthfirst visitor five only", stopVisitor.visited.size(), 5);												//break it down			for(j = 0;j < instance.size();++j) {				instance.removeEdge(instance.get(0), instance.get(j));				}						for(i = 0;i < instance.size();++i) {				if(i == 0) {					assertEquals('i == 0 incoming edges left', instance.getInDegree(instance.get(i)), size - 1);					assertEquals('i == 0no more outgoing edges left', instance.getOutDegree(instance.get(i)), 0);				}else {										assertEquals('i != 0 ncoming edges left (all edges except ourself and for index 0', instance.getInDegree(instance.get(i)), size - 2);					assertEquals('i != 0 outgoing edges left', instance.getOutDegree(instance.get(i)), size - 1);				}			}						for(i = 0;i < instance.size();++i) {				for(j = 0;j < instance.size();++j) {					instance.removeEdge(instance.get(i), instance.get(j));					}			}						//all nodes removed			for(i = 0;i < instance.size();++i) {				assertEquals('no more incoming edges left', instance.getInDegree(instance.get(i)), 0);				assertEquals('no more ougoing edges left', instance.getOutDegree(instance.get(i)), 0);			}		}						public function testGraphDegree():void{			trace("GraphTest.testGraphDegree(): directed and undirected");			var gd: GraphDegree;			var a : GraphNode = new GraphNode("a");			var b : GraphNode = new GraphNode("b");			var c : GraphNode = new GraphNode("c");			var d : GraphNode = new GraphNode("d");			var e : GraphNode = new GraphNode("e");			var x : GraphNode = new GraphNode("x");									//first test undirected			reset(false);			gd = new GraphDegree(instance);			assertEquals('dummy thing', 0, gd.getDegree(new GraphNode("a")));				instance.add(a);			instance.add(b);			instance.add(c);			instance.add(d);			instance.add(e);			instance.add(x);			//undirected graph			instance.addEdge(a, b);			instance.addEdge(a,c);			instance.addEdge(b,c);			instance.addEdge(b,d);			instance.addEdge(c, d);			instance.addEdge(d, e);							gd = new GraphDegree(instance);			assertEquals(gd.getDegree(a), 2);			assertEquals(instance.getDegree(a), 2);			assertEquals(instance.getInDegree(a), 2);			assertEquals(instance.getOutDegree(a), 2);						assertEquals(gd.getDegree(b), 3);			assertEquals(instance.getDegree(b), 3);			assertEquals(instance.getInDegree(b), 3);			assertEquals(instance.getOutDegree(b), 3);						assertEquals(gd.getDegree(x), 0);			assertEquals(instance.getDegree(x), 0);			assertEquals(instance.getInDegree(x), 0);			assertEquals(instance.getOutDegree(x), 0);																		//now, test directed			reset(true);				//new nodes			a = new GraphNode("a");			b = new GraphNode("b");			c = new GraphNode("c");			d = new GraphNode("d");			e = new GraphNode("e");			x = new GraphNode("x");			gd = new GraphDegree(instance);			assertEquals(0, gd.getDegree(new GraphNode("a")));			instance.add(a);			instance.add(b);			instance.add(c);			instance.add(d);			instance.add(e);			instance.add(x);			//directed graph			instance.addEdge(a, b);			instance.addEdge(a,c);			instance.addEdge(b,c);			instance.addEdge(b,d);			instance.addEdge(c, d);			instance.addEdge(d, e);							gd = new GraphDegree(instance);			assertEquals('degree of a', gd.getDegree(a), 2);			assertEquals('degree of a',instance.getDegree(a), 2);			assertEquals('degree of a',instance.getInDegree(a), 0);			assertEquals('degree of a',instance.getOutDegree(a), 2);						assertEquals('degree of b',gd.getDegree(b), 3);			assertEquals('degree of b',instance.getDegree(b), 3);			assertEquals('degree of b',instance.getInDegree(b), 1);			assertEquals('degree of b',instance.getOutDegree(b), 2);						assertEquals('degree of d',gd.getDegree(d), 3);			assertEquals('degree of d',instance.getDegree(d), 3);			assertEquals('degree of d',instance.getInDegree(d), 2);			assertEquals('degree of d',instance.getOutDegree(d), 1);						assertEquals('degree of x',gd.getDegree(x), 0);			assertEquals('degree of x',instance.getDegree(x), 0);			assertEquals('degree of x',instance.getInDegree(x), 0);			assertEquals('degree of x',instance.getOutDegree(x), 0);				}								public function testDenseGraphTraversalUndirected() : void {			trace("GraphTest.testDenseGraphTraversalUndirected(): df and bf");			reset(false);			var size : int = 100;			var node : GraphNode;			var edge : GraphEdge;						//build the nodes			RunTimer.start();			for(var i : int = 0;i < size;++i) {				instance.add(Math.random() * 10000000);			}			RunTimer.traceRunTime("added graph nodes: " + size, true);			RunTimer.start();			//connect all nodes to all edges, totally undirected, dense graph			for(i = 0;i < instance.size();++i) {				//only connect to ones we haven't connected to yet (undirected remember ;) )				for(var j : int = i;j < instance.size();++j) {					instance.addEdge(instance.get(i), instance.get(j));					}			}			RunTimer.traceRunTime("connected all nodes with edges: " + size, true);						//check all nodes connected			assertEquals(instance.size(), size);			assertEquals(instance.getInDegree(instance.get(1)), size - 1);			assertEquals(instance.getOutDegree(instance.get(1)), size - 1);			assertEquals(instance.getDegree(instance.get(1)), size - 1);			assertEquals(instance.getInDegree(instance.get(Math.round(size / 2))), size - 1);			assertEquals(instance.getOutDegree(instance.get(Math.round(size / 2))), size - 1);			assertEquals(instance.getDegree(instance.get(Math.round(size / 2))), size - 1);			assertEquals(instance.getInDegree(instance.get(size - 1)), size - 1);			assertEquals(instance.getOutDegree(instance.get(size - 1)), size - 1);			assertEquals(instance.getDegree(instance.get(size - 1)), size - 1);									var visitor : GraphNodeVisitor; 						//depthfirst			visitor = new GraphNodeVisitor();			RunTimer.start();			instance.depthFirst(instance.get(0), visitor);			RunTimer.traceRunTime("depthFirst: " + size, true);			assertEquals(visitor.visited.size(), size);						//out of bounds, null reference			visitor = new GraphNodeVisitor();			instance.depthFirst(instance.get(instance.size()), visitor);			assertEquals(visitor.visited.size(), 0);									//breadthfirst			visitor = new GraphNodeVisitor();			RunTimer.start();			instance.breadthFirst(instance.get(0), visitor);			RunTimer.traceRunTime("breadthFirst: " + size, true);			assertEquals(visitor.visited.size(), size);						//out of bounds, null reference			visitor = new GraphNodeVisitor();			instance.breadthFirst(instance.get(instance.size()), visitor);			assertEquals(visitor.visited.size(), 0);						//connection stats			RunTimer.start();			var cc : ConnectedComponents = new ConnectedComponents(instance);			RunTimer.traceRunTime("check create connection of graph: " + size, true);			assertEquals(cc.getConnectionCount(), 1);			RunTimer.start();			assertEquals(cc.getConnected(instance.get(1), instance.get(size - 1)), true);			assertEquals(cc.getConnected(instance.get(1), instance.get(Math.round(size / 2))), true);			assertEquals(cc.getConnected(instance.get(size - 2), instance.get(size - 1)), true);			assertEquals(cc.getConnected(instance.get(size - 2), instance.get(Math.round(size / 2))), true);			assertEquals(cc.getConnected(instance.get(Math.floor(Math.random() * size)), instance.get(size - 1)), true);			assertEquals(cc.getConnected(instance.get(Math.floor(Math.random() * size)), instance.get(Math.round(size / 2))), true);			RunTimer.traceRunTime("diverse connection queries: " + size, true);									//breadthfirst			var stopVisitor : GraphNodeVisitorFiveOnly = new GraphNodeVisitorFiveOnly();			RunTimer.start();			instance.breadthFirst(instance.get(0), stopVisitor);			RunTimer.traceRunTime("breadthFirst five only: " + size, true);			assertEquals("breadthfirst visitor five only", stopVisitor.visited.size(), 5);						//breadthfirst			stopVisitor = new GraphNodeVisitorFiveOnly();			RunTimer.start();			instance.depthFirst(instance.get(0), stopVisitor);			RunTimer.traceRunTime("breadthFirst five only: " + size, true);			assertEquals("depthfirst visitor five only", stopVisitor.visited.size(), 5);												//break it down			//undirected, so this removes all			for(j = 0;j < instance.size();++j) {				if(j == 0){					assertFalse('removing self edge from ' + j, instance.removeEdge(instance.get(0), instance.get(j)));				}else{					assertTrue('removing edge from ' + j, instance.removeEdge(instance.get(0), instance.get(j)));									}				}			assertEquals("j", j, size);						for(i = 0;i < instance.size();++i) {				if(i == 0) {					assertEquals('i == 0 incoming edges left', instance.getInDegree(instance.get(i)), 0);					assertEquals('i == 0 no more outgoing edges left', instance.getOutDegree(instance.get(i)), 0);					assertEquals('i == 0 no more edges left', instance.getDegree(instance.get(i)), 0);				}else {					//size -2: for i=0 everything has been removed, for all others, everything to and from 0					assertEquals('i ==' + i +' incoming edges left', instance.getInDegree(instance.get(i)), size - 2);					assertEquals('i ==' + i +' outgoing edges left', instance.getOutDegree(instance.get(i)), size - 2);					assertEquals('i ==' + i +' edges left', instance.getDegree(instance.get(i)),  size - 2);				}			}						for(i = 0;i < instance.size();++i) {				for(j = 0;j < instance.size();++j) {					instance.removeEdge(instance.get(i), instance.get(j));					}			}						//all nodes removed			for(i = 0;i < instance.size();++i) {				assertEquals('no more incoming edges left', instance.getInDegree(instance.get(i)), 0);				assertEquals('no more ougoing edges left', instance.getOutDegree(instance.get(i)), 0);			}		}						public function testDepthFirstAndDegree() : void {			trace("GraphTest.testDepthFirstAndDegree()");			reset(true);			instance.add("a");			instance.add("b");			instance.add("c");			instance.add("d");			instance.add("e");						var visitor : GraphNodeVisitor; 						visitor = new GraphNodeVisitor();			instance.depthFirst(instance.get(0), visitor);			assertEquals(GraphNode(visitor.visited.get(0)).getData(), "a");			assertEquals(visitor.visited.size(), 1);						visitor = new GraphNodeVisitor();			instance.depthFirst(instance.get(1), visitor);			assertEquals(GraphNode(visitor.visited.get(0)).getData(), "b");			assertEquals(visitor.visited.size(), 1);						instance.addEdge(instance.get(0), instance.get(1));			//a-b						instance.addEdge(instance.get(1), instance.get(2));			//b-c						instance.addEdge(instance.get(2), instance.get(1));			//c-b						instance.addEdge(instance.get(2), instance.get(0));			//c-a				//seperate component			instance.addEdge(instance.get(3), instance.get(4));			//d-e				assertEquals(GraphNode(instance.get(0)).getOutDegree(), 1);					assertEquals(GraphNode(instance.get(4)).getOutDegree(), 0);					assertEquals(GraphNode(instance.get(3)).getOutDegree(), 1);					assertEquals(GraphNode(instance.get(2)).getOutDegree(), 2);					//two seperate components//			var cc : ConnectedComponents = new ConnectedComponents(instance);//			assertEquals(cc.getConnectionCount(), 2);//			assertTrue(cc.getConnected(instance.get(0), instance.get(1)));//			assertTrue(cc.getConnected(instance.get(1), instance.get(2)));//			assertTrue(cc.getConnected(instance.get(3), instance.get(4)));//			assertTrue(cc.getConnected(instance.get(4), instance.get(3)));//			assertFalse(cc.getConnected(instance.get(0), instance.get(4)));//			assertFalse(cc.getConnected(instance.get(0), instance.get(3)));//			assertFalse(cc.getConnected(instance.get(3), instance.get(2)));//			assertFalse(cc.getConnected(instance.get(3), instance.get(1)));//			assertFalse(cc.getConnected(instance.get(4), instance.get(1)));//			assertFalse(cc.getConnected(instance.get(4), instance.get(2)));						//start at "a" -- only a-b-c			visitor = new GraphNodeVisitor();			instance.depthFirst(instance.get(0), visitor);			assertEquals(visitor.visited.size(), 3);						//start at 'e' -- only d-e, so NO e to d			visitor = new GraphNodeVisitor();			assertEquals(GraphNode(instance.get(4)).getOutDegree(), 0);					assertEquals(GraphNode(instance.get(3)).getOutDegree(), 1);					instance.depthFirst(instance.get(4), visitor);			assertEquals('d connected to e', visitor.visited.size(), 1);			instance.addEdge(instance.get(4), instance.get(3));			//e-d			assertEquals(GraphNode(instance.get(4)).getOutDegree(), 1);					assertEquals(GraphNode(instance.get(3)).getOutDegree(), 1);					//start at 'e' -- e-d and d-e			visitor = new GraphNodeVisitor();			instance.depthFirst(instance.get(4), visitor);			assertEquals('d and e fully connected', visitor.visited.size(), 2);												instance.addEdge(instance.get(0), instance.get(3));			//a-d						instance.addEdge(instance.get(2), instance.get(4));			//c-e						visitor = new GraphNodeVisitor();			assertEquals(instance.size(), 5);			instance.depthFirst(instance.get(0), visitor);			//trace(visitor.visited.toArray().toString());			assertEquals('visit all nodes', visitor.visited.size(), 5);		}						public function testUndirectedGraph():void{			trace("GraphTest.testUndirectedGraph()");			reset(false);			instance.add("a");			instance.add("b");			instance.add("c");			instance.add("d");			instance.add("e");							var cc : ConnectedComponents;						cc = new ConnectedComponents(instance);			assertEquals(cc.getConnectionCount(), 5);			assertFalse(cc.getConnected(instance.get(0), instance.get(1)));			assertFalse(cc.getConnected(instance.get(0), instance.get(2)));			assertFalse(cc.getConnected(instance.get(0), instance.get(3)));			assertFalse(cc.getConnected(instance.get(0), instance.get(4)));			assertFalse(cc.getConnected(instance.get(1), instance.get(0)));			assertFalse(cc.getConnected(instance.get(2), instance.get(0)));			assertFalse(cc.getConnected(instance.get(3), instance.get(0)));			assertFalse(cc.getConnected(instance.get(4), instance.get(0)));						//add an edge, bidirectional reference			instance.addEdge(instance.get(0), instance.get(1));			cc = new ConnectedComponents(instance);			assertEquals(cc.getConnectionCount(), 4);			assertTrue(cc.getConnected(instance.get(0), instance.get(1)));			assertFalse(cc.getConnected(instance.get(0), instance.get(2)));			assertFalse(cc.getConnected(instance.get(0), instance.get(3)));			assertFalse(cc.getConnected(instance.get(0), instance.get(4)));			assertTrue(cc.getConnected(instance.get(1), instance.get(0)));			assertFalse(cc.getConnected(instance.get(2), instance.get(0)));			assertFalse(cc.getConnected(instance.get(3), instance.get(0)));			assertFalse(cc.getConnected(instance.get(4), instance.get(0)));			//degrees of relevatn nodes			assertEquals(instance.getDegree(instance.get(0)), 1);			assertEquals(instance.getDegree(instance.get(1)), 1);			assertEquals(instance.getOutDegree(instance.get(0)), 1);			assertEquals(instance.getOutDegree(instance.get(1)), 1);			assertEquals(instance.getInDegree(instance.get(0)), 1);			assertEquals(instance.getInDegree(instance.get(1)), 1);			//degree of other nodes			assertEquals(instance.getDegree(instance.get(2)), 0);			assertEquals(instance.getDegree(instance.get(3)), 0);			assertEquals(instance.getOutDegree(instance.get(2)), 0);			assertEquals(instance.getOutDegree(instance.get(3)), 0);			assertEquals(instance.getInDegree(instance.get(2)), 0);			assertEquals(instance.getInDegree(instance.get(3)), 0);						//remove the edge			instance.removeEdge(instance.get(0), instance.get(1));			cc = new ConnectedComponents(instance);			assertEquals(cc.getConnectionCount(), 5);			assertFalse(cc.getConnected(instance.get(0), instance.get(1)));			assertFalse(cc.getConnected(instance.get(0), instance.get(2)));			assertFalse(cc.getConnected(instance.get(0), instance.get(3)));			assertFalse(cc.getConnected(instance.get(0), instance.get(4)));			assertFalse(cc.getConnected(instance.get(1), instance.get(0)));			assertFalse(cc.getConnected(instance.get(2), instance.get(0)));			assertFalse(cc.getConnected(instance.get(3), instance.get(0)));			assertFalse(cc.getConnected(instance.get(4), instance.get(0)));			assertEquals(instance.getDegree(instance.get(0)), 0);			assertEquals(instance.getDegree(instance.get(1)), 0);			assertEquals(instance.getOutDegree(instance.get(0)), 0);			assertEquals(instance.getOutDegree(instance.get(1)), 0);			assertEquals(instance.getInDegree(instance.get(0)), 0);			assertEquals(instance.getInDegree(instance.get(1)), 0);			//other nodes			assertEquals(instance.getDegree(instance.get(2)), 0);			assertEquals(instance.getDegree(instance.get(3)), 0);			assertEquals(instance.getOutDegree(instance.get(2)), 0);			assertEquals(instance.getOutDegree(instance.get(3)), 0);			assertEquals(instance.getInDegree(instance.get(2)), 0);			assertEquals(instance.getInDegree(instance.get(3)), 0);					}		public function testConnectedCompontents() : void {			trace("GraphTest.testConnectedCompontents()");			reset(false);			instance.add("a");			instance.add("b");			instance.add("c");			instance.add("d");			instance.add("e");												instance.addEdge(instance.get(0), instance.get(1));			//a-b						instance.addEdge(instance.get(1), instance.get(2));			//b-c						instance.addEdge(instance.get(2), instance.get(1));			//c-b						instance.addEdge(instance.get(2), instance.get(0));			//c-a				//seperate component			instance.addEdge(instance.get(3), instance.get(4));			//d-e				assertEquals(GraphNode(instance.get(0)).getOutDegree(), 2);					assertEquals(GraphNode(instance.get(4)).getOutDegree(), 1);					assertEquals(GraphNode(instance.get(3)).getOutDegree(), 1);					assertEquals(GraphNode(instance.get(2)).getOutDegree(), 2);					//two seperate components			var cc : ConnectedComponents = new ConnectedComponents(instance);			assertEquals(cc.getConnectionCount(), 2);			assertTrue(cc.getConnected(instance.get(0), instance.get(1)));			assertTrue(cc.getConnected(instance.get(1), instance.get(2)));			assertTrue(cc.getConnected(instance.get(3), instance.get(4)));			assertTrue(cc.getConnected(instance.get(2), instance.get(0)));			assertTrue(cc.getConnected(instance.get(4), instance.get(3)));			assertFalse(cc.getConnected(instance.get(0), instance.get(4)));			assertFalse(cc.getConnected(instance.get(0), instance.get(3)));			assertFalse(cc.getConnected(instance.get(3), instance.get(2)));			assertFalse(cc.getConnected(instance.get(3), instance.get(1)));			assertFalse(cc.getConnected(instance.get(4), instance.get(1)));			assertFalse(cc.getConnected(instance.get(4), instance.get(2)));		}		/**		 * tests the CLASS		 */		public function testBFS() : void {			trace("GraphTest.testBFS()");				reset(false);				var a : GraphNode = new GraphNode("a");			var b : GraphNode = new GraphNode("b");			var c : GraphNode = new GraphNode("c");			var d : GraphNode = new GraphNode("d");			var e : GraphNode = new GraphNode("e");			var x : GraphNode = new GraphNode("x");			instance.add(a);			instance.add(b);			instance.add(c);			instance.add(d);			instance.add(e);			instance.add(x);			//undirected graph			instance.addEdge(a, b);			instance.addEdge(b, x);			instance.addEdge(a, x);			instance.addEdge(d, a);			instance.addEdge(x, c);			instance.addEdge(c, d);			instance.addEdge(d, e);									var visitor : IGraphVisitor;			var bfs : BreadthFirstSearch;			var sp : List; 									visitor = new GraphVisitor();			bfs = new BreadthFirstSearch(instance, a, visitor);						//shortest path			sp = bfs.getShortestPath(c);			assertEquals(sp.size(), 2);			assertEquals(GraphNode(sp.get(0)).getData(), "a");			assertEquals(GraphNode(sp.get(1)).getData(), "x");			//another one			sp = bfs.getShortestPath(e);			assertEquals(sp.size(), 2);			assertEquals(GraphNode(sp.get(0)).getData(), "a");			assertEquals(GraphNode(sp.get(1)).getData(), "d");						//another one			sp = bfs.getShortestPath(x);			assertEquals(sp.size(), 1);			assertEquals(GraphNode(sp.get(0)).getData(), "a");								}		/**		 * this method sets up all stuff we need before we run the test		 */		protected override function setUp() : void {			reset(true);		}				/**		 *	use to remove all stuff not needed after this test		 */		protected override function tearDown() : void {			instance = null;		}	}}