package nl.dpdk.collections {	import nl.dpdk.collections.sorting.Comparators;	import nl.dpdk.collections.lists.LinkedList;	import nl.dpdk.collections.trees.BinarySearchTree;	import nl.dpdk.collections.trees.BinaryTreeNode;	import nl.dpdk.debug.RunTimer;	
	public class BinarySearchTreeTest extends CollectionTest {		private var instance : BinarySearchTreeLookInside;		//how many alphabets do we store in basic setup?		private var totalAlphabets : int = 20;		//spankme is the number of times totalAlphabets		private var spankMe : int = 5 * totalAlphabets;		//random data		private var bushy : Array;
		/**		 * constructor		 */		public function BinarySearchTreeTest(testMethod : String = null) {			super(testMethod);		}
		
		/**		 * this method sets up all stuff we need before we run the test		 */		protected override function setUp() : void {			instance = new BinarySearchTreeLookInside(Comparators.compareStringCaseInsensitive);		}
		
		/**		 *	use to remove all stuff not needed after this test		 */		protected override function tearDown() : void {			instance = null;		}
		
		/**		 *	a test implementation		 */		public function testInstantiated() : void {			assertTrue("BinarySearchTree instantiated", instance is BinarySearchTree);		}
		
		public function testIterator() : void {			trace("BinarySearchTreeTest.testIterator()");			basicSetup(3);			//should be inOrder			trace(instance.toArray());			}
		
		public function testClear() : void {			instance.add("a");			assertTrue(instance.contains('a'));			assertFalse(instance.isEmpty());			assertEquals(instance.size(), 1);			instance.clear();			assertTrue(instance.isEmpty());				assertEquals(instance.size(), 0);			assertFalse(instance.contains('a'));		}
		
		public function testSearch() : void {			trace("BinarySearchTreeTest.testSearch()");						RunTimer.start();			basicSetup(totalAlphabets);			RunTimer.traceRunTime('after first basic setup', true);			var search : String;			var i : int, j : int;			//now search  on all strings we stored			RunTimer.start();			for(i = 0;i < totalAlphabets; ++i) {				for(j = 0;j < alphabetLength;++j) {					search = (alphabet.charAt(j) + i);					//trace(search);					assertEquals('search ' + search, instance.search(search), search);					}				}			RunTimer.traceRunTime("after " + (totalAlphabets * alphabetLength) + " searches and assertions on the bst", true);			assertFalse(instance.contains('bogus'));			assertFalse(instance.contains('a' + totalAlphabets));			assertFalse(instance.contains('a'));			assertFalse(instance.contains('aa'));			assertFalse(instance.contains('z' + totalAlphabets));			assertTrue(instance.contains('z' + (totalAlphabets - 1)));			assertTrue(instance.contains('a' + (totalAlphabets - 1)));						assertNull("bogus search is null", instance.search("bogus"));			assertNotNull("search of a returns non null", instance.search("a0"));			/**			 * now copy to linked list, and do another search to compare runtimes			 */			RunTimer.start();			 			var ll : LinkedList = new LinkedList(instance);			RunTimer.traceRunTime('after copying to linked list');			RunTimer.start();			for( i = 0;i < totalAlphabets; ++i) {				for( j = 0;j < alphabetLength;++j) {					search = (alphabet.charAt(j) + i);					//trace(search);					assertTrue('search ' + search, ll.contains(search));					}				}			RunTimer.traceRunTime("after " + (totalAlphabets * alphabetLength) + " searches and assertions on the same linked list", true);						assertFalse(ll.contains('bogus'));			assertFalse(ll.contains('a' + totalAlphabets));			assertFalse(ll.contains('a'));			assertFalse(ll.contains('aa'));			assertFalse(ll.contains('z' + totalAlphabets));			assertTrue(ll.contains('z' + (totalAlphabets - 1)));			assertTrue(ll.contains('a' + (totalAlphabets - 1)));			/**			 * now copy to array list, and do another search to compare runtimes			 */			RunTimer.start();			 			var arrayList : LinkedList = new LinkedList(instance);			RunTimer.traceRunTime('after copying to array list');			RunTimer.start();			for( i = 0;i < totalAlphabets; ++i) {				for( j = 0;j < alphabetLength;++j) {					search = (alphabet.charAt(j) + i);					//trace(search);					assertTrue('search ' + search, arrayList.contains(search));					}				}			RunTimer.traceRunTime("after " + (totalAlphabets * alphabetLength) + " searches and assertions on the same array list", true);						assertFalse(arrayList.contains('bogus'));			assertFalse(arrayList.contains('a' + totalAlphabets));			assertFalse(arrayList.contains('a'));			assertFalse(arrayList.contains('aa'));			assertFalse(arrayList.contains('z' + totalAlphabets));			assertTrue(arrayList.contains('z' + (totalAlphabets - 1)));			assertTrue(arrayList.contains('a' + (totalAlphabets - 1)));												//now spank me			var total:int = spankMe;			RunTimer.start();			basicSetup(total)			RunTimer.traceRunTime('basic setup time for ' + total + " alphabets", true);			RunTimer.start();			for(i = 0;i < total; ++i) {				for(j = 0;j < alphabetLength;++j) {					search = (alphabet.charAt(j) + i);					//trace(search);					assertEquals('search ' + search, instance.search(search), search);					}				}			RunTimer.traceRunTime("spankme after " + (total * alphabetLength) + " searches and assertions", true);		}
		
		private function basicSetup(howMuchAlphabets : int) : void {			instance.clear();			instance = new BinarySearchTreeLookInside(Comparators.compareStringCaseInsensitive);						/**			 * this will create a right leaning bst, which is very unoptimized			 */			for(var i : int = 0;i < howMuchAlphabets; ++i) {				for(var j : int = 0;j < alphabetLength;++j) {					instance.add(alphabet.charAt(j) + i);					}				}		}
		
		private function bushySetup() : BinarySearchTreeLookInside {			var bst : BinarySearchTreeLookInside = new BinarySearchTreeLookInside(Comparators.compareStringCaseInsensitive);			var rand : Number;				bushy = new Array();			var char : String;			var output : String;			for(var i : int = 0;i < 1000; ++i) {				//prevent duplicates by making random very large				rand = Math.round(Math.random() * 100000000);				char = alphabet.charAt(Math.round(Math.random() * alphabetLength));				//semi random string				output = char + rand;				bushy.push(output);				bst.add(output);					}			return bst;		}
		
		/**		 * look at the structure of the bst		 */		public function testLookInside() : void {			trace("BinarySearchTreeTest.testLookInside()");			basicSetup(totalAlphabets);			var root : BinaryTreeNode = instance.getRoot();			trace('height of basic tree: ' + root.getHeight());			trace('size of basic tree: ' + root.size());						/**			 * first test constructor functionality and iterator functionality of bst			 * the adding will take place in a different order because  of the inner iterator that was built.			 * so we do not yet test the implementation of  the structure			 */			var inside : BinarySearchTreeLookInside = new BinarySearchTreeLookInside(Comparators.compareStringCaseInsensitive, instance);			var search : String;			var i : int, j : int;						//basic test			for(i = 0;i < totalAlphabets; ++i) {				for(j = 0;j < alphabetLength;++j) {					search = (alphabet.charAt(j) + i);					assertTrue('search ' + search, inside.contains(search));				}				}						root = inside.getRoot();			trace('height of basic tree copied via constructor: ' + root.getHeight());			trace('size of basic tree copied via constructor: ' + root.size());						/**			 * now clear, setup			 * this creates a right leaning bst, unoptimized but predictable			 */			inside.clear();			for(i = 0;i < totalAlphabets; ++i) {				for(j = 0;j < alphabetLength;++j) {					search = (alphabet.charAt(j) + i);					inside.add(search);					}				}						root = inside.getRoot();			assertEquals("root.d", root.getData(), 'a0');			assertEquals("root.l", root.getLeft(), null);			assertEquals("root.r", root.getRight().getData(), 'b0');			assertEquals("root.r.r", root.getRight().getRight().getData(), 'c0');			assertEquals("root.r.l", root.getRight().getLeft().getData(), 'a1');						/**			 * test for largest and smallest stuff			 */			inside.clear();			for(j = 0;j < 80;++j) {				search = alphabet.charAt(Math.floor(Math.random() * alphabetLength));				inside.add(search);				}			search = 'zzzzzzzzzzzzz';			inside.add(search);						root = inside.getRoot();			while(root.getRight()) root = root.getRight();			assertEquals("the largest element is the rightmost element", root.getData(), search);						search = 'a';			inside.add(search);			root = inside.getRoot();			while(root.getLeft()) root = root.getLeft();			assertEquals("the smallest element is the leftmost element", root.getData(), search);						RunTimer.start();			inside = bushySetup() as BinarySearchTreeLookInside;			RunTimer.traceRunTime('bushy setup time', true);			root = inside.getRoot();			//compare to bushy array			assertEquals('bushy root.d', root.getData(), bushy[0]);			RunTimer.start();			for(i = 0;i < bushy.length;++i) {				//trace('bushy: ' + bushy[i]);				assertEquals('bushy tree contains ' + bushy[i], inside.search(bushy[i]), bushy[i]);				}			RunTimer.traceRunTime('after ' + bushy.length + ' searches', true);						var node : BinaryTreeNode;						node = root;			while(node) {				if(node.getLeft()) {					node = node.getLeft();				}else {					break;				}				}			trace('node.level of leftmost bushy: ' + node.getLevel());			node = root;			while(node) {				if(node.getRight()) {					node = node.getRight();				}else {					break;				}				}			trace('node.level of rightmost bushy: ' + node.getLevel());			trace('height of tree bushy: ' + root.getHeight());			trace('size of tree bushy: ' + root.size());		}
		
		public function testRemove() : void {			trace("BinarySearchTreeTest.testRemove()");						/**			 * test removal with nodes with no children			 */			instance.clear();			/**			 * root deletion with no children			 */			assertTrue(instance.isEmpty());			assertEquals(instance.size(), 0);			instance.add("a");			assertEquals(instance.size(), 1);			assertFalse(instance.isEmpty());			assertTrue(instance.remove('a'));			assertTrue(instance.isEmpty());			assertEquals(instance.size(), 0);						/**			 * left and right deletion with no children			 */			 //left			instance.add('a');			instance.add('b');			instance.remove('b');			//right			instance.add('b3');			instance.add('b2');			instance.remove('b2');			trace(instance.toArray());									/**			 * test deletion with one child			 */			 //delettion on the root node			 instance.clear();			 instance.add('b');			 //right node of root, with right child			 instance.add('c');			 instance.add('c1');			 instance.remove('c');			 trace(instance.toArray());			 trace(instance.toArray());			  //left node of root, with left child			 instance.add('a1');			 instance.add('a0');			 instance.remove('a1');			 trace(instance.toArray());			 //delete root with left child			 instance.clear();			 instance.add('a1');			 instance.add('a0');			 instance.remove('a1');			 trace(instance.toArray());			 			 //delete root with right child			 instance.clear();			 instance.add('a0');			 instance.add('a1');			 instance.remove('a0');			 trace(instance.toArray());			 			 			 			 			 /**			  * test deletion of nodes with two childs			  */			  instance.clear();			  instance.add('k');			  instance.add('a');			  instance.add('z');			  //root deletion			  instance.remove('k');			  trace(instance.toArray());			  			  			  			  						//return ;			basicSetup(3);			trace(instance.toArray());			var size: int = instance.size();			trace('size before removing: ' + instance.size());			assertTrue(instance.remove("b0"));			assertEquals(instance.size(), --size);			//trace('b0 removed: ' +instance.toArray());			assertTrue(instance.remove("z2"));			assertEquals(instance.size(), --size);			//trace('z2 removed: ' +instance.toArray());			assertTrue(instance.remove("a0"));			assertEquals(instance.size(), --size);			//trace('a0 removed: ' + instance.toArray());						assertTrue(instance.remove("g0"));			assertEquals(instance.size(), --size);			//trace('g0 removed: ' + instance.toArray());						assertTrue(instance.remove("z0"));			assertEquals(instance.size(), --size);			//trace('z0 removed: ' + instance.toArray());									assertTrue('remove xo' + instance.remove("x0"));			assertEquals(instance.size(), --size);			assertFalse(instance.contains('x0'));			trace('x0 removed: ' + instance.toArray());			assertTrue(instance.remove("x1"));			assertFalse(instance.contains('x01'));			assertEquals(instance.size(), --size);			trace('x1 removed: ' + instance.toArray());			assertTrue(instance.remove("b2"));			assertFalse(instance.contains('b2'));			assertEquals(instance.size(), --size);			trace('b2 removed: ' + instance.toArray());			assertTrue(instance.remove("c1"));			assertFalse(instance.contains('c1'));			assertEquals(instance.size(), --size);			trace('c1 removed: ' + instance.toArray());			assertTrue(instance.remove("e1"));			assertFalse(instance.contains('e1'));			assertEquals(instance.size(), --size);			trace('e1 removed: ' + instance.toArray());			assertTrue(instance.remove("e2"));			assertFalse(instance.contains('e2'));			assertEquals(instance.size(), --size);			trace('e2 removed: ' + instance.toArray());			assertTrue(instance.remove("e0"));			assertFalse(instance.contains('e0'));			assertEquals(instance.size(), --size);			trace('e0 removed: ' + instance.toArray());//						//size is correct when testing			trace('size is now: ' + instance.size());			trace(instance.toString());			trace(instance.toArray());			//TODO, remove all in levelorder, inorder, postorder and preorder!					}
		
		public function testConstructor() : void {			trace("BinarySearchTreeTest.testConstructor()");			var a : BinarySearchTreeLookInside = new BinarySearchTreeLookInside(Comparators.compareStringCaseInsensitive, new LinkedList());			assertTrue('is empty', a.isEmpty());			assertFalse('cannot remove', a.remove('bogus'));				assertEquals('size 0', a.size(), 0);			var b : LinkedList = new LinkedList();			b.add('a');			b.add('b');			b.add('c');			a = new BinarySearchTreeLookInside(Comparators.compareStringCaseInsensitive, b);			assertFalse('not empty', a.isEmpty());			assertEquals('size 3', a.size(), 3);			assertTrue('contains c', a.contains('c'));			assertTrue('contains b', a.contains('b'));			assertTrue('contains a', a.contains('a'));			assertFalse('not contains bogus', a.contains('bogus'));			assertFalse('not contains 0', a.contains(0));			try {				assertFalse('not contains null', a.contains(null));				fail('cannot pass null in a comparison method for strings');			}catch(e : Error) {			}		}	}}