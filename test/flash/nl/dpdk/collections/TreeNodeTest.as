package nl.dpdk.collections {	import nl.dpdk.collections.iteration.IIterator;	import nl.dpdk.collections.iteration.IIteratorExtended;	import nl.dpdk.collections.lists.List;	import nl.dpdk.collections.trees.ITreeNode;	import nl.dpdk.collections.trees.ITreeNodeVisitor;	import nl.dpdk.collections.trees.TreeNode;	import nl.dpdk.debug.RunTimer;	
	public class TreeNodeTest extends CollectionTest implements ITreeNodeVisitor {		private var instance : TreeNode;		private	var a : String = "a";		private	var b : String = "b";		private	var c : String = "c";		private	var d : String = "d";		private	var e : String = "e";		private	var f : String = "f";		private	var g : String = "g";		private	var h : String = "h";		private	var i : String = "i";		private	var j : String = "j";		private	var k : String = "k";		private	var l : String = "l";		private	var m : String = "m";		private	var n : String = "n";		private	var o : String = "o";		private	var p : String = "p";		private	var q : String = "q";		private	var r : String = "r";		private	var s : String = "s";		private	var t : String = "t";		private	var u : String = "u";		private	var v : String = "v";		private	var w : String = "w";		private	var x : String = "x";		private	var y : String = "y";		private	var z : String = "z";		private	var zz : String = "zz";
		/**		 * constructor		 */		public function TreeNodeTest(testMethod : String = null) {			super(testMethod);		}
		
		public function testConstructor() : void {			trace("TreeNodeTest.testConstructor()");			instance = new TreeNode(b, new TreeNode(a));			assertTrue('a is parent of b', instance.getParent().getData() == 'a');				assertEquals('size', instance.size(), 1);			assertEquals('level', instance.getLevel(), 1);			assertEquals('height', instance.getHeight(), 1);			assertEquals('our data', instance.getData(), 'b');			assertEquals('childcount of parent', instance.getParent().getChildCount(), 1);			assertEquals('sibling count', instance.getSiblingCount(), 0);		}
		
		public function testSizeLevelHeightChildrenSiblings() : void {			trace("TreeNodeTest.testSizeLevelHeightChildrenSiblings()");			basicSetup();				assertEquals('root + alphabet size', instance.size(), 27);			assertEquals(instance.getLevel(), 0);			assertEquals(instance.getChildren().get(0).getLevel(), 1);			assertEquals('size of a', instance.getChildren().get(0).size(), 7);			assertEquals('size of b', instance.getChildren().get(1).size(), 9);			assertEquals(instance.getChildren().get(0).getChildren().get(0).getLevel(), 2);						assertEquals('height of instance: root/a/e/q', instance.getHeight(), 4);			//add a node, and test the new height			instance.getChildren().get(1).getChildren().get(2).getChildren().get(1).add('test');			assertEquals('height of instance: root/b/j/w/test', instance.getHeight(), 5);			assertEquals('root + alphabet size + test', instance.size(), 28);			instance.getChildren().get(1).getChildren().get(2).getChildren().get(1).remove('test');			assertEquals('root + alphabet size - test', instance.size(), 27);			trace(instance.getChildren().get(0).getSiblings().toArray().toString());			assertFalse('siblings of a  have a, but not on the sibling list as this contains nodes! search on the node instead', instance.getChildren().get(0).getSiblings().contains('a'));			assertFalse('siblings of a have b, but not on the sibling list as this contains nodes!', instance.getChildren().get(0).getSiblings().contains('b'));			assertFalse('siblings of a have c, but not on the sibling list as this contains nodes!', instance.getChildren().get(0).getSiblings().contains('c'));			assertFalse('siblings of a have d, but not on the sibling list as this contains nodes!', instance.getChildren().get(0).getSiblings().contains('d'));									assertTrue('children of root, search directly on a node a', instance.contains('a'));			assertTrue('children of root, search directly on a node b', instance.contains('b'));			assertTrue('children of root, search directly on a node c', instance.contains('c'));			assertTrue('children of root, search directly on a node d', instance.contains('d'));			assertTrue('children of root, search directly on a node z', instance.contains('z'));			assertFalse('children of root, search directly on a node test', instance.contains('test'));			instance.add('test');			assertTrue('children of root, search directly on a node test-', instance.contains('test'));			assertTrue('remove test when it is there returns true', instance.remove('test'));			assertEquals('root + alphabet size - test', instance.size(), 27);			assertFalse('remove test when it is not there returns false', instance.remove('test'));			assertEquals('root + alphabet size - test', instance.size(), 27);						assertFalse('does not contain bogus', instance.contains('asdf'));			assertFalse('does not contain bogus', instance.contains(null));									assertEquals('childcount of root', instance.getChildCount(), 4);			assertEquals('childcount of root/a ', instance.getChildren().get(0).getChildCount(), 3);			assertEquals('childcount of root/b/i ', instance.getChildren().get(1).getChildren().get(1).getChildCount(), 1);			assertEquals('childcount of root/b/j ', instance.getChildren().get(1).getChildren().get(2).getChildCount(), 3);		}
		
		public function testTraversal() : void {			trace("TreeNodeTest.testTraversal()");				basicSetup();			RunTimer.start();			var visitor : Visitor = new Visitor();			TreeNode.breadthFirst(instance, visitor);			trace('breadthFirst: ', visitor.getResult());			assertEquals('breadfirst result', visitor.getResult().toString(), 'root,a,e,q,f,r,g,s,b,h,t,i,u,j,v,w,x,c,k,y,z,l,m,d,n,o,p');			assertEquals('did we traverse everything in breadthFirst?', visitor.getResult().length, 27);			RunTimer.traceRunTime('recursive breadthfirst', true);						RunTimer.start();			visitor = new Visitor();			TreeNode.depthFirst(instance, visitor);			trace('depthFirst: ', visitor.getResult());			assertEquals('did we traverse everything in depthFirst?', visitor.getResult().length, 27);			assertEquals('depthFirst result', visitor.getResult().toString(), 'q,e,r,f,s,g,a,t,h,u,i,v,w,x,j,b,y,z,k,l,m,c,n,o,p,d,root');			RunTimer.traceRunTime('recursive depthFirst', true);						RunTimer.start();			visitor = new Visitor();			TreeNode.levelOrder(instance, visitor);			trace('levelOrder: ', visitor.getResult());			assertEquals('did we traverse everything in levelorder?', visitor.getResult().length, 27);			assertEquals('levelOrder result', visitor.getResult().toString(), 'root,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z');			RunTimer.traceRunTime('levelOrder', true);						instance.add('test');			RunTimer.start();			visitor = new Visitor();			TreeNode.levelOrder(instance, visitor);			trace('levelOrder: ', visitor.getResult());			assertEquals('did we traverse everything in levelorder when test was added?', visitor.getResult().length, 28);			assertEquals('levelOrder result with test', visitor.getResult().toString(), 'root,a,b,c,d,test,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z');			RunTimer.traceRunTime('levelOrder', true);						instance.remove('s');			RunTimer.start();			visitor = new Visitor();			TreeNode.levelOrder(instance, visitor);			trace('levelOrder: ', visitor.getResult());			assertEquals('did we traverse everything in levelorder when s was removed?', visitor.getResult().length, 27);			assertEquals('levelOrder result when s was removed (part of subtree of a)', visitor.getResult().toString(), 'root,a,b,c,d,test,e,f,g,h,i,j,k,l,m,n,o,p,q,r,t,u,v,w,x,y,z');			RunTimer.traceRunTime('levelOrder', true);			instance.remove('a');						RunTimer.start();			visitor = new Visitor();			TreeNode.levelOrder(instance, visitor);			trace('levelOrder: ', visitor.getResult());			assertEquals('did we traverse everything in levelorder (we removed a subtree of 7, but s was already removed) ?', visitor.getResult().length, 21);			assertEquals('levelOrder result when the subtree a is removed', visitor.getResult().toString(), 'root,b,c,d,test,h,i,j,k,l,m,n,o,p,t,u,v,w,x,y,z');			RunTimer.traceRunTime('levelOrder', true);						instance.clear();			assertEquals(instance.size(), 1);			//total alphabets			var size : int = 1000;			//SIZE of the tree			var total : int = (size * alphabetLength) + 1;			alphabetSetup(size);			assertEquals(instance.getData(), null);			instance.setData('root');			assertEquals(instance.getData(), 'root');						assertEquals(instance.size(), total);			RunTimer.start();			assertEquals(instance.size(), total);			RunTimer.traceRunTime('size calculation for ' + total + ' items', true);									RunTimer.start();			visitor = new Visitor();			TreeNode.breadthFirst(instance, visitor);			RunTimer.traceRunTime('breadthFirst ' + total, true);			assertEquals(visitor.getResult().length, total);						RunTimer.start();			visitor = new Visitor();			TreeNode.depthFirst(instance, visitor);			RunTimer.traceRunTime('depthFirst ' + total, true);			assertEquals(visitor.getResult().length, total);						RunTimer.start();			visitor = new Visitor();			TreeNode.levelOrder(instance, visitor);			RunTimer.traceRunTime('levelOrder ' + total, true);			assertEquals(visitor.getResult().length, total);			//trace(visitor.getResult().toString());		}
		
		private function alphabetSetup(howmanyalphabets : Number) : void {			//this basically creates a very long list on the rootnode			for(var i : int = 0;i < alphabetLength;++i) {				for(var j : int = 0;j < howmanyalphabets;++j) {					instance.add(alphabet.charAt(i) + '' + j);				}			}		}
		
		private function basicSetup() : void {			instance = new TreeNode("root");			instance.add(a);			instance.add(b);			instance.add(c);			instance.add(d);						var firstLevel : List = instance.getChildren();			var secondLevel : List;			var iterator : IIteratorExtended = firstLevel.iteratorExtended();			var node : TreeNode;			node = iterator.next() as TreeNode;			//the 'a' node			node.add(e);			node.add(f);			node.add(g);			node = iterator.next() as TreeNode;			//the 'b' node			node.add(h);			node.add(i);			node.add(j);			node = iterator.next() as TreeNode;			//the 'c' node			node.add(k);			node.add(l);			node.add(m);			node = iterator.next() as TreeNode;			//the 'd' node			node.add(n);			node.add(o);			node.add(p);						iterator.begin();			node = iterator.next() as TreeNode;			secondLevel = node.getChildren();			//e node			TreeNode(secondLevel.get(0)).add(q);			//f node			TreeNode(secondLevel.get(1)).add(r);			//g node			TreeNode(secondLevel.get(2)).add(s);			node = iterator.next() as TreeNode;			secondLevel = node.getChildren();			//h node			TreeNode(secondLevel.get(0)).add(t);			//i node			TreeNode(secondLevel.get(1)).add(u);			//j node			TreeNode(secondLevel.get(2)).add(v);			TreeNode(secondLevel.get(2)).add(w);			TreeNode(secondLevel.get(2)).add(x);			node = iterator.next() as TreeNode;			secondLevel = node.getChildren();			//hknode			TreeNode(secondLevel.get(0)).add(y);			TreeNode(secondLevel.get(0)).add(z);		}		
		
		/**		 * this method sets up all stuff we need before we run the test		 */		protected override function setUp() : void {			instance = new TreeNode(a);		}
		
		/**		 *	use to remove all stuff not needed after this test		 */		protected override function tearDown() : void {			instance = null;		}
		
		/**		 *	a test implementation		 */		public function testInstantiated() : void {			assertTrue("TreeNode instantiated", instance is TreeNode);		}
		
		public function visit(node : ITreeNode) : void {		}	}}