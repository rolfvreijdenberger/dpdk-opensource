package nl.dpdk.loader{	import nl.dpdk.collections.lists.PriorityQueueNode;	import asunit.framework.TestCase;	import nl.dpdk.collections.sorting.SortOrder;	/**	 * TODO: Rewrite this based on the current implementaton of Loader.	 * getIsActive works differently for example ...	 * 	 * @author Thomas Brekelmans	 */	public class ComparatorTest extends TestCase	{		public function ComparatorTest(testMethod:String = null) 		{			super(testMethod);		}		override protected function setUp():void		{		}		override protected function tearDown():void		{		}				public function testALoadersInDefaultState():void		{			var priorityA:int = Priorities.LOWEST;			var priorityB:int = Priorities.HIGHEST;						var nodeA:PriorityQueueNode = new PriorityQueueNode(priorityA);			var nodeB:PriorityQueueNode = new PriorityQueueNode(priorityB);			var loaderA:Loader = new Loader(priorityA);			var loaderB:Loader = new Loader(priorityB);			nodeA.setData(loaderA);			nodeB.setData(loaderB);						assertEquals("default state of a loader is not active, so priority is ignored", Comparator.compareLoaders(nodeA, nodeB), SortOrder.EQUAL);		}				public function testBLoadersInActiveState():void		{			var priorityA:int = Priorities.LOWEST;			var priorityB:int = Priorities.HIGHEST;						var nodeA:PriorityQueueNode = new PriorityQueueNode(priorityA);			var nodeB:PriorityQueueNode = new PriorityQueueNode(priorityB);			var loaderA:Loader = new Loader(priorityA);			var loaderB:Loader = new Loader(priorityB);			nodeA.setData(loaderA);			nodeB.setData(loaderB);						// adding an empty statement to set the criteria for getActive() right so the loaders becomes active and can be used for testing			loaderA.add("");			loaderB.add("");						assertEquals("both loaders are active, so priority is considered, a has lowest, b has highest, so less", Comparator.compareLoaders(nodeA, nodeB), SortOrder.LESS);						loaderA.setPriority(priorityB);			loaderB.setPriority(priorityA);			// manual updating because these loaders do not live in a queue that reprioritizes the nodes for you			nodeA.setPriority(priorityB);			nodeB.setPriority(priorityA);						assertEquals("both loaders are active, so priority is considered, a has highest, b has lowest, so larger", Comparator.compareLoaders(nodeA, nodeB), SortOrder.LARGER);						loaderA.setPriority(priorityA);			loaderB.setPriority(priorityA);			// manual updating because these loaders do not live in a queue that reprioritizes the nodes for you			nodeA.setPriority(priorityA);			nodeB.setPriority(priorityA);						assertEquals("both loaders are active, so priority is considered, a has lowest, b has lowest, so equal", Comparator.compareLoaders(nodeA, nodeB), SortOrder.EQUAL);		}				public function testCOneLoaderInActiveState():void		{			var priorityA:int = Priorities.LOWEST;			var priorityB:int = Priorities.HIGHEST;						var nodeA:PriorityQueueNode = new PriorityQueueNode(priorityA);			var nodeB:PriorityQueueNode = new PriorityQueueNode(priorityB);			var loaderA:Loader = new Loader(priorityA);			var loaderB:Loader = new Loader(priorityB);			nodeA.setData(loaderA);			nodeB.setData(loaderB);						// adding an empty statement to set the criteria for getActive() right so the loader becomes active and can be used for testing			loaderA.add("");						assertEquals("one loader is active, so priority is not considered, a has lowest, but a is active so larger", Comparator.compareLoaders(nodeA, nodeB), SortOrder.LARGER);						loaderA.setPriority(priorityB);			loaderB.setPriority(priorityA);			// manual updating because these loaders do not live in a queue that reprioritizes the nodes for you			nodeA.setPriority(priorityB);			nodeB.setPriority(priorityA);						assertEquals("one loader is active, so priority is not considered, a has highest, b has lowest, a is still active as well so larger", Comparator.compareLoaders(nodeA, nodeB), SortOrder.LARGER);						loaderA.setPriority(priorityA);			loaderB.setPriority(priorityA);			// manual updating because these loaders do not live in a queue that reprioritizes the nodes for you			nodeA.setPriority(priorityA);			nodeB.setPriority(priorityA);						assertEquals("one loader is active, so priority is not considered, a has lowest, b has lowest, but a is active so still larger", Comparator.compareLoaders(nodeA, nodeB), SortOrder.LARGER);		}	}}