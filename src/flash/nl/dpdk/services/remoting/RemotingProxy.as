/*Copyright (c) 2008 De Pannekoek en De Kale B.V.,  www.dpdk.nlPermission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the "Software"), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included inall copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS INTHE SOFTWARE. */package nl.dpdk.services.remoting {	import nl.dpdk.collections.iteration.IIterator;	import nl.dpdk.collections.lists.List;	import nl.dpdk.collections.lists.LinkedList;	import nl.dpdk.log.Log;	import nl.dpdk.services.remoting.StatusData;	import flash.events.AsyncErrorEvent;	import flash.events.Event;	import flash.events.EventDispatcher;	import flash.events.IEventDispatcher;	import flash.events.IOErrorEvent;	import flash.events.NetStatusEvent;	import flash.events.SecurityErrorEvent;	import flash.net.NetConnection;	import flash.net.ObjectEncoding;	import flash.net.Responder;	import flash.utils.Proxy;	import flash.utils.flash_proxy;		[Event(name="ERROR_IO", type="nl.dpdk.services.remoting.RemotingEvent")]	[Event(name="ERROR_NETSTATUS", type="nl.dpdk.services.remoting.RemotingEvent")]	[Event(name="ERROR_SECURITY", type="nl.dpdk.services.remoting.RemotingEvent")]	[Event(name="ERROR_ASYNC", type="nl.dpdk.services.remoting.RemotingEvent")]	[Event(name="ERROR_TIMEOUT", type="nl.dpdk.services.remoting.RemotingEvent")]	/**	 * RemotingProxy is a subclass of Proxy (and thus dynamic) which handles all traffic with a Remoting-based gateway using AMF.	 * The events we can register to are in the class RemotingEvent.	 * It also lets us register callback methods for the result and status events that come in whenever we have a result or a status event from a remote call.	 * The gateway is typically a php based gateway (in our case either weborb or amfphp).	 * <p><p>	 * use as follows:	 * <code>	 * var proxy: RemotingProxy = new RemotingProxy(myGateway, myService);	 * proxy.addHandler('remoteMethodToCall', myResultFunction, myStatusFunction);	 * proxy.remoteMethodToCall(myObject, 'a string', 'etcetera');	 * </code>	 * @see RemotingEvent	 * @see ResultData	 * @see StatusData	 * @see ResultSet	 * @author Thomas Brekelmans, Rolf Vreijdenberger	 */	dynamic final public class RemotingProxy extends Proxy implements IEventDispatcher {		//the gateway, a uri		private var gateway : String;		//the service we call through the gateway. can also be a classpath.		private var service : String;		//the list of handlers for diverse remote method calls.		private var methodHandlers : List;		//the netconnection on which we call our methods		private var netConnection : NetConnection;		//this class is an eventDispatcher through composition		private var eventDispatcher : EventDispatcher;		//the timeOut value if a call has no response, defaults to 0 (no timeout)		private var timeOut : int = 0;		/**		 * Creates a new RemotingProxy instance pointing to a given gateway and service with an optional ObjectEncoding.		 * After creating an instance of RemotingProxy and registering the event listeners and adding the handlers, the client can make direct calls on the instance which will be proxied to the remote service. 		 * @param gateway	Specifies the URL of the gateway. 		 * @param service	Specifies the name of the service that will be connected to. This might be a complete remote classpath (such as nl.dpdk.users.User)		 * @param objectEncoding	(optional) Defines which type of ObjectEncoding is used to interface with the gateway (defaults to ObjectEncoding.AMF0, can also be set to ObjectEncoding.AMF3).		 * @see RemotingEvent		 */		public function RemotingProxy(gateway : String, service : String, objectEncoding : uint = 0) {			this.gateway = gateway;			this.service = service;			eventDispatcher = new EventDispatcher();			methodHandlers = new LinkedList();			netConnection = new NetConnection();			netConnection.objectEncoding = objectEncoding;			netConnection.addEventListener(IOErrorEvent.IO_ERROR, onIOError);			netConnection.addEventListener(AsyncErrorEvent.ASYNC_ERROR, onAsyncError);			netConnection.addEventListener(SecurityErrorEvent.SECURITY_ERROR, onSecurityError);			netConnection.addEventListener(NetStatusEvent.NET_STATUS, onNetConnectionNetStatus);						connect();		}				/**		 * set a timeout on this instance. 		 * The default timeout is 0, which means NO timeout detection.		 * Every remote method that takes longer than this timeOut time will trigger a RemotingEvent.ERROR_TIMEOUT.		 * On top of that, if there is a result after the timeout period it will be discarded.		 * @param timeOut the timeout period in milliseconds. To be set correctly, it must be either 0 or more than 250 milliseconds.		 */		public function setTimeOut(timeOut : int) : void {			if(timeOut == 0 || timeOut > 250 ) {				this.timeOut = timeOut;			}		}				/**		 * Adds a context header to the AMF packet structure. This header is sent with every future AMF packet.		 */		public final function addHeader(operation : String, mustUnderstand : Boolean = false, param : Object = null) : void {			netConnection.addHeader(operation, mustUnderstand, param);		}				/**		 * Actually connects to the gateway specified in the constructor.		 * @throws an error if connection fails.		 */		private function connect() : void {			//Does not catch an error with a gateway that does not exist.			try {				netConnection.connect(gateway);			}			catch (error : Error) {				Log.debug(error.message, toString());				}		}				/**		 * this method provides the proxy functionality. 		 * It lets you call methods on this class that will be redirected to this method if they do not exist.		 * They will be redirected to the remote service.		 */		flash_proxy override function callProperty(methodName : *, ...args) : * {			//the responder object that handles the response from the remote call			var responder : Responder = new RemotingResponder(methodName, onResult, onStatus, onTimeOut, timeOut);			//construct an array with all the necessary parameters for netconnection.call()			var callArguments : Array;			if (args.length > 0) {				callArguments = [service + "." + methodName, responder].concat(args);			}else {				callArguments = [service + "." + methodName, responder];			}			//call the remote service method with the correct arguments			netConnection.call.apply(null, callArguments);			return;		}				/**		 * this is required to allow remotingProxyInstance[someDynamicPropertyOrMethodName] or even		 * remotingProxyInstance[someDynamicMethodName].apply(null, args);		 */		override flash_proxy function getProperty(name : *) : * {			return name;		}				/**		 * alternative to dynamic method calling.		 * instead of directly caling myProxy.someMethod(myArgument) a client can also call myProxy.invoke('someMethod', myArgument);		 * @param methodName the name of the remote method to be called.		 * @param args an argument list to pass to the remote method.		 */		public function invoke(methodName : String, ...args) : void {			//TODO, have both callProperty and invoke call another method, no duplicate logic.			//the responder object that handles the response from the remote call			var responder : Responder = new RemotingResponder(methodName, onResult, onStatus, onTimeOut, timeOut);			//construct an array with all the necessary parameters for netconnection.call()			var callArguments : Array;			if (args.length > 0) {				callArguments = [service + "." + methodName, responder].concat(args);			}else {				callArguments = [service + "." + methodName, responder];			}			//call the remote service method with the correct arguments			netConnection.call.apply(null, callArguments);		}		/**		 * called by the responder object when a remote call timed out.		 */		private function onTimeOut(method : String, timeOut : int) : void {			eventDispatcher.dispatchEvent(new RemotingEvent(RemotingEvent.ERROR_TIMEOUT, "call to " + method + ' failed after a timeout of ' + timeOut + ' milliseconds'));			}		/**		 * Callback for the responder object used in netConnection.call		 * @param methodName The name of the remote  method that was called. it will be called with a parameter of type ResultData.		 * @param result The raw remoting result data.		 */		private function onResult(methodName : String, result : *) : void {			//now call all registered listeners			var affectedMethodHandlers : List = methodHandlers.selectBy(new MethodNameSpecification(methodName));			if(affectedMethodHandlers.size() == 0) {				return;				}						var data : *;			if (result is Number || result is String || result is Boolean || result is Array || result is int || result is uint) {				// Primitive type or built-in Class				data = result;			}			//check for lower and uppercase 'i' in serverInfo			else if (result is Object && ( result.serverInfo != null || result.serverinfo != null)) {				//ResultSet, convert into a usable form				data = ResultSetFactory.create(result);			}			else {				//associative array / object or unknown				data = result;			}						var resultData : ResultData = new ResultData(data);			var handler : Function;			var methodHandler : MethodHandler;			var iterator : IIterator = affectedMethodHandlers.iterator();			while(iterator.hasNext()) {				methodHandler = iterator.next() as MethodHandler;				handler = methodHandler.getResultHandler();				//invoke the callback				handler(resultData);			}		}				/**		 * Callback for the responder object used in netConnection.call		 * @param methodName The name of the remote method that was called. it will be called with a parameter of type StatusData.		 * @param status The remoting status data.		 */		private function onStatus(methodName : String, status : *) : void {			var affectedMethodHandlers : List = methodHandlers.selectBy(new MethodNameSpecification(methodName));			if(affectedMethodHandlers.isEmpty()) {				//check for the right usage. this might also be because this object is a proxy and someone is doing something unintentionally but is not warned by the compiler.				Log.debug("onStatus() was called for a call to '" + methodName + "' but no handler was created.", toString());				return;				}						var iterator : IIterator = affectedMethodHandlers.iterator();			var handler : Function;			var methodHandler : MethodHandler;			var statusData : StatusData;			//do amf0 and amf3 handle error objects differently? I saw this as being flex.messaging.messages.ErrorMessage somewhere...			if(status.description != null){				 statusData = new StatusData(status.description, status.details, status.level, status.line, status.code);			}else if(status.faultString != null){				 statusData = new StatusData(status.faultString, status.faultDetail, "UNKNOW LEVEL", status.correlationId, status.faultCode);							}			while(iterator.hasNext()) {				methodHandler = iterator.next() as MethodHandler;				handler = methodHandler.getStatusHandler();				//invoke the callback				handler(statusData);			}		}				/**		 * Defines the result and error/status handler for a given method name that will be called when a method with the given name is called on the RemotingProxy.		 * @param remoteMethod	The name of the remote method that will be called via this proxy.		 * @param resultHandler	Reference to the result function that will be called when a result came back from the server.		 * @param statusHandler	Reference to the error/status function that will be called when an error comes back from the server.		 * @see removeHandler		 */		public function addHandler(remoteMethod : String, resultHandler : Function, statusHandler : Function) : void {			var toCheck : List = methodHandlers.selectBy(new MethodSpecification(remoteMethod, resultHandler, statusHandler));			if(toCheck.isEmpty()) {				methodHandlers.add(new MethodHandler(remoteMethod, resultHandler, statusHandler));			}		}				/**		 * removes previously registered handlers.		 * @param remoteMethod	The name of the remote method that would be called via this proxy.		 * @param resultHandler	Reference to the result function that would  be called when a result came back from the server.		 * @param statusHandler	Reference to the error/status function that would  be called when an error comes back from the server.		 * @return true if the handler was found, false if it was not found.		 * @see removeHandler		 */		public function removeHandler(remoteMethod : String, resultHandler : Function, statusHandler : Function) : Boolean {			var toRemove : List = methodHandlers.selectBy(new MethodSpecification(remoteMethod, resultHandler, statusHandler));			if(toRemove.isEmpty()) {				//no handler found				return false;			}			var iterator : IIterator = toRemove.iterator();			while(iterator.hasNext()) {				methodHandlers.remove(iterator.next());			}			return true;		}				private function onIOError(e : IOErrorEvent) : void {			eventDispatcher.dispatchEvent(new RemotingEvent(RemotingEvent.ERROR_IO, e.text));		}				private function onAsyncError(e : AsyncErrorEvent) : void {			eventDispatcher.dispatchEvent(new RemotingEvent(RemotingEvent.ERROR_ASYNC, e.text));				}				private function onSecurityError(e : SecurityErrorEvent) : void {			eventDispatcher.dispatchEvent(new RemotingEvent(RemotingEvent.ERROR_SECURITY, e.text));						}				/**		 * Callback for the NetStatusEvent.NET_STATUS sent from the netConnection instance which calls invokeErrorHandlers or invokeConnectHandlers based on the info code from the event.		 * @param e	The net status event object sent from the netConnection instance.		 */		private function onNetConnectionNetStatus(e : NetStatusEvent) : void {			switch(e.info.code) {				case "NetConnection.Connect.Closed": 					//The connection was closed successfully.					break;				case "NetConnection.Connect.Success": 					// The connection attempt succeeded.					break;				case "NetConnection.Call.BadVersion": 					// Packet encoded in an unidentified format.				case "NetConnection.Call.Failed": 					//The NetConnection.call method was not able to invoke the server-side method or command.				case "NetConnection.Call.Prohibited": 					//An Action Message Format (AMF) operation is prevented for security reasons. Either the AMF URL is not in the same domain as the SWF file, or the AMF server does not have a policy file that trusts the domain of the SWF file.				default:					//all possible other stuff that could happen					eventDispatcher.dispatchEvent(new RemotingEvent(RemotingEvent.ERROR_NETSTATUS, e.info.code));									break;			}		}				/**		 * Destroys all references to the RemotingProxy to make it ready to be deleted.		 */		public function destroy() : void {			try {							methodHandlers.clear();				netConnection.removeEventListener(IOErrorEvent.IO_ERROR, onIOError);				netConnection.removeEventListener(AsyncErrorEvent.ASYNC_ERROR, onAsyncError);				netConnection.removeEventListener(SecurityErrorEvent.SECURITY_ERROR, onSecurityError);				netConnection.removeEventListener(NetStatusEvent.NET_STATUS, onNetConnectionNetStatus);				netConnection.close();			}catch(e : Error) {			}		}				public function dispatchEvent(event : Event) : Boolean {						return eventDispatcher.dispatchEvent(event);		}				public function hasEventListener(type : String) : Boolean {			return eventDispatcher.hasEventListener(type);		}				public function willTrigger(type : String) : Boolean {			return eventDispatcher.willTrigger(type);		}				public function removeEventListener(type : String, listener : Function, useCapture : Boolean = false) : void {			eventDispatcher.removeEventListener(type, listener, useCapture);		}				public function addEventListener(type : String, listener : Function, useCapture : Boolean = false, priority : int = 0, useWeakReference : Boolean = false) : void {			eventDispatcher.addEventListener(type, listener, useCapture, priority, useWeakReference);		}				/**		 * Returns a String representation of the current RemotingProxy instance.		 */		public function toString() : String {			return "RemotingProxy for service: " + service;		}				/**		 * @return the current remote service we are using to call methods on		 */		public function getService() : String {			return service;		}				/**		 * sets the remote service we will use to call methods on		 * @param service the remote service, can also be a classpath eg: nl.dpdk.users.User		 */		public function setService(service : String) : void {			this.service = service;		}	}}import nl.dpdk.specifications.Specification;import flash.net.Responder;import flash.utils.Timer;/** * Internal class which is used to preserve the link between a name and a resultHandler and statusHandler. */internal class MethodHandler {	private var method : String;	private var resultHandler : Function;	private var statusHandler : Function;	public function MethodHandler(remoteMethod : String, resultHandler : Function, statusHandler : Function) {		this.method = remoteMethod;		this.resultHandler = resultHandler;		this.statusHandler = statusHandler;	}		public function getMethod() : String {		return method;	}		public function getResultHandler() : Function {		return resultHandler;	}		public function getStatusHandler() : Function {		return statusHandler;	}}/** * Specification used to select the affected methods. */internal class MethodNameSpecification extends Specification {	protected var methodName : String;	public function MethodNameSpecification(methodName : String) {		this.methodName = methodName;	}		override public function isSatisfiedBy(object : *) : Boolean {		var methodHandler : MethodHandler = object as MethodHandler;		return (methodHandler.getMethod() == methodName);	}}internal class MethodSpecification extends MethodNameSpecification {	private var resultHandler : Function;	private var statusHandler : Function;	public function MethodSpecification(methodName : String, resultHandler : Function, statusHandler : Function) {		super(methodName);		this.statusHandler = statusHandler;		this.resultHandler = resultHandler;	}		override public function isSatisfiedBy(object : *) : Boolean {		var handler : MethodHandler = object as MethodHandler;		return (handler.getMethod() == methodName && handler.getStatusHandler() == statusHandler && handler.getResultHandler() == resultHandler);	}}import flash.events.TimerEvent;/** * the responder class for the call on a netconnection. * it stores the methodname of the method that was called remotely, so we can find the right callbacks to call in a response to either a result or an error. */internal class RemotingResponder extends Responder {	private var methodName : String;	private var resultHandler : Function;	private var statusHandler : Function;	private var timer : Timer;	private var timeOutHandler : Function;	private var invalidated : Boolean;	public function RemotingResponder(methodName : String, resultHandler : Function, statusHandler : Function,  timeOutHandler : Function = null, timeOut : int = 0) {		//trace("RemotingResponder.RemotingResponder(methodName, resultHandler, statusHandler, timeOutHandler, timeOut)");		//call the constructor on super, with handlers that are defined in this class		super(onResult, onStatus);		//store additional information we need when the handlers are called.		this.methodName = methodName;		this.statusHandler = statusHandler;		this.resultHandler = resultHandler;		this.invalidated = false;		//if there is a timeout set..		if(timeOut != 0) {			this.timeOutHandler = timeOutHandler;			this.timer = new Timer(timeOut, 1);			this.timer.addEventListener(TimerEvent.TIMER_COMPLETE, onTimeOut);			this.timer.start();		}		}	private function onTimeOut(event : TimerEvent) : void {		invalidated = true;		timeOutHandler(methodName, timer.delay);	}			private function stopTimer() : void {		if(timer) {			timer.stop();			timer.removeEventListener(TimerEvent.TIMER_COMPLETE, onTimeOut);		}	}		private function onResult(data : *) : void {		stopTimer();		if(!invalidated) {			resultHandler(methodName, data);			}	}		private function onStatus(data : *) : void {		stopTimer();		if(!invalidated) {			statusHandler(methodName, data);			}	}}		