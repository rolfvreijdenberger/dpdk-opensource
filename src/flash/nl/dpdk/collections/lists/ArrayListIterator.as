package nl.dpdk.collections.lists {	import nl.dpdk.collections.iteration.IIteratorExtended;		internal class ArrayListIterator implements IIteratorExtended {	private var theList : ArrayList;	private var current : int = 0;	private var collection : Array;	/**	 * ugly construct(or) but necessary to get the right references from the list	 */	public function ArrayListIterator(list : ArrayList, collection : Array) {		theList = list;		this.collection = collection;		begin();	}		public function begin() : void {		current = -1;	}		public function set(data : *) : Boolean {		if(current < 0 || current >= theList.size()) {			return false;		}		collection[current] = data;			return true;	}		public function end() : void {		current = theList.size();	}		public function hasPrevious() : Boolean {		//this makes it possible to go to the previous item at the beginning of an iteration, a circular implementation		var size : int = theList.size();		return (current > 0 || current <= -1 ) && size > 0;	}		public function previous() : * {		//circular implementation		if(--current < 0) current = theList.size() - 1;		return collection[current];	}		public function hasNext() : Boolean {		var size : int = theList.size();		return (current < size - 1 || current >= size  ) && size >= 0;	}		public function next() : * {		//circular implementation		if(++current >= theList.size()) {			current = 0;		}		return collection[current];	}		public function insert(data : *) : void {		if(theList.size() == 0) {			theList.add(data);			return;		}		//insert and upgrade pointer afterwards		theList.insertAt(current++, data);	}		public function remove() : Boolean {		var result : Boolean = theList.removeAt(current);		if(result) --current;		return result;	}}}