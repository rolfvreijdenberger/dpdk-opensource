/*Copyright (c) 2008 De Pannekoek en De Kale B.V.,  www.dpdk.nlPermission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the "Software"), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included inall copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS INTHE SOFTWARE. */package nl.dpdk.collections.lists {	import nl.dpdk.collections.core.IApplyable;	import nl.dpdk.collections.core.IApplyer;	import nl.dpdk.collections.core.ICollection;	import nl.dpdk.collections.core.IFoldable;	import nl.dpdk.collections.core.IFolder;	import nl.dpdk.collections.core.IMappable;	import nl.dpdk.collections.core.IMapper;	import nl.dpdk.collections.core.IPriorityQueue;	import nl.dpdk.collections.core.IRandomAccess;	import nl.dpdk.collections.core.ISearchable;	import nl.dpdk.collections.core.ISelectable;	import nl.dpdk.collections.core.ISortable;	import nl.dpdk.collections.iteration.IIterator;	import nl.dpdk.collections.iteration.IIteratorExtended;	import nl.dpdk.collections.iteration.UnmodifiableExtendedIterator;	import nl.dpdk.collections.lists.IList;	import nl.dpdk.collections.sorting.SortOrder;	import nl.dpdk.collections.sorting.SortTypes;	import nl.dpdk.specifications.ISpecification;	/**	 * OrderedList is list that is kept ordered from small to large. As such it might be used as a PriorityQueue.	 * The ordering of a list means (in this case) that it has to be kept sorted on insertion/adding.	 * This means that every addition will take time proportional to O(N), but building a list will take time proportional to O(n^2).	 * That means that this class might be very good if it is built at the beginning of a process, followed by a lot of searches or removals (of the maximum).	 * Remove the maximum and find maximum will take time O(1).	 * <p><p>	 * As this class is based on an array implementation and is ordered, we can make this class searchable with a binary search (fast: O(lgN) in worst case!).	 * Be careful: maintaining the order may consume more time than the searches.	 * <p>	 * <p>	 * A binary search tree is faster (in average case scenarios) in insertion than the orderedlist, so for searching we might switch to this,  but this is a functionality trade off, as a List can do much more than a BST.	 * A Heap (aka BinaryHeap) for a PriorityQueue is faster than an OrderedList, but again, this is a functionality trade off.	 * <p>	 * OrderedList does not extend List as this would also give it IDeque and IQueue and IStack implementation, which does not make sense for an ordered list.	 * 	 * @see ISearchable	 * @see BinarySearchTree	 * @see IPriorityQueue	 * 	 * @author Rolf Vreijdenberger	 */	public class OrderedList implements ICollection, IList, ISortable, IFoldable, IMappable, ISelectable, IApplyable, ISearchable, IPriorityQueue, IRandomAccess {		/**		 * the data structure to hold the data		 */		private var list : List;		/**		 * the comparator function		 * @see Comparators		 */		private var comparator : Function;		/**		 * sentinel value for the bs algorithm		 */		private const BINARY_SEARCH_SENTINEL : int = -1;		/**		 * the constructor takes a comparator method to be able to add items to the list in sorted fashion and to be able to do a binary search.		 * @param comparator the comparator function to use for the sorting		 * @param collection the collection to use to initialize the list.		 * @see Comparators		 */		public function OrderedList(comparator : Function, collection : ICollection = null) {			this.comparator = comparator;			this.list = new ArrayList();			if(collection) {				addAll(collection);			}		}				/**		 * Binary search implementation.		 * time proportional to O(logN) in the worst case (which is fast).		 * @inheritDoc		 */		public function search(data : *) : * {			/**			 * binary search on an ordered array			 */			if(data == null) {				//explicitely disallow, it fucks up the comparator				return data;				}			 			if(binarySearch(data) != BINARY_SEARCH_SENTINEL) {				return data	;			}			return null;		}
		/**		 * @inheritDoc		 */		public function get(i : int) : * {			return list.get(i);
		}
		/**		 * sets the data (overwrite), and reorders.		 * @inheritDoc		 */		public function set(i : int, data : *) : void {			list.set(i, data);			list.sort(this.comparator, SortTypes.INSERTION);		}
		/**		 * @inheritDoc		 */		public function removeAt(i : int) : Boolean {			return list.removeAt(i);
		}
		/**		 * adds the data, to keep the ordering, the index specified does nothing.		 * @inheritDoc		 */		public  function insertAt(i : int, data : *) : void {			add(data);		}
		/**		 * @inheritDoc		 */		public  function indexOf(data : *) : int {			return list.indexOf(data);
		}
		/**		 * @inheritDoc		 */		public  function lastIndexOf(data : *) : int {			return list.lastIndexOf(data);
		}
										/**		 * @inheritDoc		 */		public  function subList(from : int, to : int) : List {			return list.subList(from, to);
		}
		/**		 * reverse does nothing as we lose the ordering defined by the comparator when reversing.		 * @inheritDoc		 */		public  function reverse() : void {			//do nothing			//TODO: do we want to do a reversal of the sign on the comparator's method (set a flag)?			return;		}
				/**		 * this collection returns an unmodifiable iterator.		 * More out of laziness to create a specific iterator than anything else, but because of the ordering, we don't want anyone to tinker with remove and insert on the iterator.		 * @inheritDoc		 */		public  function iteratorExtended() : IIteratorExtended {			//TODO think about this, the normal iterator can be used, cause remove causes normal behaviour. insert() and set() on the IIteratorExtended are the biatches, because it fucks up the pointer inside the iterator...			return new UnmodifiableExtendedIterator(list.iteratorExtended());
		}
		/**		 * adds the data in an ordered fashion.		 * @inheritDoc		 */		public  function add(data : *) : void {			if(data == null) {				//explicitely disallow, it fucks up the comparator				return;				}			list.add(data);			/**			 * use insertion sort as the method of choice, as it will take time proportional to O(N) for nearly sorted lists.			 */			list.sort(comparator, SortTypes.INSERTION);		}				/**		 * @inheritDoc		 */		public  function clear() : void {			list.clear();		}
		/**		 * Fast implementation, as it uses binary search.		 * @inheritDoc		 */		public  function contains(data : *) : Boolean {			if(data == null) {				return false;				}			return data == search(data) ;		}
		/**		 * @inheritDoc		 */		public  function isEmpty() : Boolean {			return list.isEmpty();
		}
		/**		 * the binary search itself, as a helper method.		 * @param data the data item to search for		 * @return the index value of the item in the list or -1 if it is a miss		 */		private function binarySearch(data : *) : int {			var right : int = size() - 1;			var left : int = 0;			var middle : int;			while (right >= left) {				/**				 * this could generate an overflow error if left and right are both very large.				 */				middle = (left + right) >> 1;				if (data == list.get(middle)) {					return middle;				}				if (comparator(data, list.get(middle)) == SortOrder.LESS) {					right = middle - 1;				}	    		else {					left = middle + 1;				}			}			//search miss			return BINARY_SEARCH_SENTINEL;		}		/**		 * Fast implementation, as it uses binary search		 * @inheritDoc		 */		public  function remove(data : *) : Boolean {			if(data == null) {				return false;				}			var index : int = binarySearch(data);			if(index != BINARY_SEARCH_SENTINEL) {				return list.removeAt(index);				}			return false;		}
		/**		 * @inheritDoc		 */		public  function size() : int {			return list.size();
		}
		/**		 * @inheritDoc		 */		public  function toArray() : Array {			return list.toArray();;
		}
		/**		 * @inheritDoc		 */		public  function toString() : String {			return "OrderedList of size " + size();		}
		/**		 * @inheritDoc		 */		public  function iterator() : IIterator {			return list.iterator();
		}
		/**		 * sorting can be done, but the new comparator will now be set in the place of the old one.		 * The default sorting type is merge, as both quicksort and insertion sort will take time of O(N^2) on an ordered list.		 * @inheritDoc		 */		public  function sort(comparator : Function, sortType : int = 6) : void {			this.comparator = comparator;			list.sort(this.comparator, sortType);		}
		/**		 * @inheritDoc		 */		public  function selectBy(specification : ISpecification) : List {			return list.selectBy(specification);
		}
		/**		 * When a command has been applied, potentially the order of the list needs to be restored.		 * While it would be too much of a performance penalty to always do this, keep this in mind when applying commands.		 * Resorting is not done here.		 * @inheritDoc		 */		public  function apply(applyer : IApplyer) : void {			list.apply(applyer);		}
		/**		 * @inheritDoc		 */		public  function map(mapper : IMapper) : List {			return list.map(mapper);
		}
		/**		 * @inheritDoc		 */		public  function fold(folder : IFolder) : * {			return list.fold(folder);
		}		/**		 * @inheritDoc		 */		public function getMaximum() : * {			return list.get(list.size() - 1);		}		/**		 * @inheritDoc		 */		public function removeMaximum() : * {			return list.removeAt(list.size() - 1);		}		/**		 * @inheritDoc		 */		public function addAll(collection : ICollection) : void {			var iterator : IIterator = collection.iterator();			while(iterator.hasNext()) {				add(iterator.next());			}		}
	}}