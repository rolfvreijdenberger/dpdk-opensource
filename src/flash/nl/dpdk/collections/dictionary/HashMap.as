/*Copyright (c) 2008 De Pannekoek en De Kale B.V.,  www.dpdk.nlPermission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the "Software"), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included inall copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS INTHE SOFTWARE. */package nl.dpdk.collections.dictionary {	import nl.dpdk.collections.iteration.ArrayIterator;	import nl.dpdk.collections.iteration.IIterable;	import nl.dpdk.collections.iteration.IIterator;		/**	 * A HashMap symbol table (key/value pairs) with strings as keys.	 * The map grows when there is need for more space, to optimize the hashing of the keys	 * @author rolf vreijdenberger	 */	public class HashMap implements IIterable {		/*		 * number of items in the hashmap		 */		private var theSize : int;		/*		 * holds the items, a dynamic array		 */		private var map : Array;		/*		 * original size of the hashmap. used when clearing the map.		 */		private var originalSize : int;		/*		 * we allow resizing of the map, therefore we need to keep a reference to the current size.		 * we double the size of the array each time it fills up. 		 * Because of this, array reallocation may be required, and in the worst case an insertion may require O(N). 		 * However, a sequence of n insertions can always be done in O(N) time, so the amortized time per operation is O(N) / N = O(1)		 */		private var currentSize : int;				/**		 * Constructor.		 * @param size the size of the map as we begin. The map will grow dynamically if it needs to.		 */		public function HashMap(size : int = 100) {			theSize = 0;			originalSize = currentSize = size < 100 ? 100 : size;			map = new Array(currentSize);		}		/**		 * clears the hashMap		 */		public function clear() : void {			theSize = 0;			currentSize = originalSize;			map = new Array(currentSize);		}				/**		 * the hashing function. a generic hashing function for keys of strings.		 * It's public for testing purposes only. You shouldn't have to use this method, except for playing around :)		 * @param key the key we want to have an index for in the range of the size parameter.		 * @param size the current size of the map we're generating an index for		 * @return an index in the range of 0 to size - 1		 */		public function hash(key : String, size : int) : int {			var index : int = 0;			var prime1 : int = 31415;			var prime2 : int = 27183;			var l : int = key.length;			for(var i : int = 0;i < l;++i) {				index = ((prime1 * index) + key.charCodeAt(i)) % size;				prime1 = prime1 * prime2 % (size - 1);			}			return index;		}		/**		 * simpler hashing method.		 * testing only		 */		private function alternateHash(key : String, size : int) : int {			var index : int = 0;			var prime : int = 127;			var l : int = key.length;			for(var i : int = 0;i < l;++i) {				index = (prime * index + key.charCodeAt(i)) % size;			}			return index;		}				/**		 * linear search, time proportional to O(N).		 * @param data checks if a certain data item is present		 */		public function contains(data : *) : Boolean {			var node : Node;			for(var i : int = 0;i < map.length;++i) {				node = map[i] as Node;				while(node) {					if(node.data == data) {						return true;					}					node = node.next;				}			}			return false;		}		/**		 * does this map contain any items?		 */		public function isEmpty() : Boolean {			return theSize == 0;		}		/**		 * removes the data item associated with a certain key.		 */		public final function remove(key : String) : Boolean {			var index : int = hash(key, currentSize);			var node : Node = map[index] as Node;			if(node == null) {				return false;			}			while(node) {				if(node.key == key) {					if(node.prev) {						node.prev.next = node.next;					} else {						//first node, update reference to avoid losing a pointer into the linked list						map[index] = node.next;					}					if(node.next) {						node.next.prev = node.prev;					}					node.prev = null;					node.next = null;					node.key = null;					node.data = null;					node = null;					--theSize;					return true;				}				node = node.next;			}			//shouldn't happen			return false;		}				/**		 * insert a new data item associated to a given key.		 * @return true if insertion was succesful, false when the insertion actually overwrites a present key value		 */		public final function insert(key : String, data : *) : Boolean {			var newNode : Node = new Node();			var node : Node;			newNode.key = key;			newNode.data = data;			var index : int = hash(key, currentSize);			if(map[index] == null) {				//new node				map[index] = newNode;			} else {				node = map[index];				//check existing nodes				while(node) {					if(node.key == key) {						//overwrite						node.data = data;						return false;					}					node = node.next;				}				//prepend				node = map[index];				node.prev = newNode;				newNode.next = node;				map[index] = newNode;			}			++theSize;						//allow growth of the map			if(theSize >= (currentSize >> 1)) {				expand();			}			return true;		}		/**		 * doubles the size of the map.		 * this allows for amortized time per operation of O(1).		 */		private function expand() : void {			//grow twice as big			currentSize = currentSize << 1;			//copy the old map			var old : Array = map.concat();			//create a bigger map			map = new Array(currentSize);			var l : int = old.length;			var node : Node;			//reset the size			theSize = 0;			//insert all the stuff present in the old map			for(var i : int = 0;i < l;++i) {				node = old[i] as Node;				while(node) {					insert(node.key, node.data);					node = node.next;				}			}			old = null;			node = null;		}						/**		 * search for data associated with a given key.		 * @param key the key whose associated data item we want to retrieve.		 * @return the data item we wanted, or null if not found.		 */		public final function search(key : String) : * {			var index : int = hash(key, currentSize);			var node : Node = map[index] as Node;			if(node == null) {				return null;			}			while(node) {				if(node.key == key) {					return node.data;				}				node = node.next;			}			return null;		}		/**		 * the number of items present in the map.		 */		public function size() : int {			return theSize;		}		/**		 * return an iterator for all keys in the map		 */		public function keyIterator() : IIterator {			var array : Array = new Array();			var node : Node;			var l : int = map.length;			for(var i : int = 0;i < l;++i) {				node = map[i] as Node;				while(node) {					array.push(node.key);					node = node.next;				}			}			return new ArrayIterator(array);		}		/**		 * returns an array of all data items.		 * takes time O(N) to generate.		 */		public function toArray() : Array {			var array : Array = new Array();			var node : Node;			var l : int = map.length;			for(var i : int = 0;i < l;++i) {				node = map[i] as Node;				while(node) {					array.push(node.data);					node = node.next;				}			}			return array;		}		/**		 * a string representation of the map.		 */		public function toString() : String {			return "HashMap(" + originalSize + ") of size: " + theSize;		}		/**		 * returns an iterator over all the data items in the map.		 */		public function iterator() : IIterator {			return new ArrayIterator(toArray());		}	}}