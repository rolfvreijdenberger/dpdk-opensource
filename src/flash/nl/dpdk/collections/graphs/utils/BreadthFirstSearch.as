/*Copyright (c) 2008 De Pannekoek en De Kale B.V.,  www.dpdk.nlPermission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the "Software"), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included inall copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS INTHE SOFTWARE. */package nl.dpdk.collections.graphs.utils {	import nl.dpdk.collections.core.IQueue;	import nl.dpdk.collections.graphs.Graph;	import nl.dpdk.collections.graphs.GraphEdge;	import nl.dpdk.collections.graphs.GraphNode;	import nl.dpdk.collections.iteration.IIterator;	import nl.dpdk.collections.lists.LinkedList;	import nl.dpdk.collections.lists.List;		import flash.utils.Dictionary;	
	/**	 * This util class provides extra functionality (three part processing and shortestpath) when doing searches on undirected graphs.	 * It does a search and a setup in the constructor. The search can be queried directly via the IGraphVisitor.	 * After that, the class can be queried to get the shortes path from diverse endpoints.	 * It is less in performance than the breadthFirst search on the graph itself, but this one is more powerful in processing, including the ability to get a shortest path after processing.	 * After preprocessing in the constructor, getShortestPath() takes lineair time.	 * @author rolf vreijdenberger	 */	public class BreadthFirstSearch {		/**		 * the visited/processed status of nodes (holds multiple states)		 * instead of keeping the states in seperate dictionaries, we just do some bitwise stuff to save memory		 */		private var status : Dictionary;		//the parent of each node when the search tree has been generated, this can be used to get a shortest path		private var parents : Dictionary;		//the graph we're processing		private var graph : Graph;		//the states of the status per GraphNode		//initialization value		private static const BLANK : int = 0;		//discovered value		private static const DISCOVERED : int = 1 << 0;		//visited value		private static const VISITED : int = 1 << 1;				/**		 * @param graph the graph we want to query		 * @param node the node that is the start of our search		 * @param visitor an implementation of IGraphVisitor that can do some powerful processing		 */		public function BreadthFirstSearch(graph : Graph, node : GraphNode, visitor : IGraphVisitor) : void {			if(graph.isDirected()){				trace("BreadthFirstSearch constructor called with a directed graph. processing not done.");					return;			}			prepare(graph);			var queue : IQueue = new LinkedList();			var edge : GraphEdge;			var nextNode : GraphNode;			var iterator : IIterator;			var edges : List;			//put the beginning node in the queue			queue.enqueue(node);			//and set it to discovered			status[node] |= DISCOVERED;			while(!queue.isEmpty()) {				node = queue.dequeue() as GraphNode;				//visit the node before any stuff is done				visitor.visitNodeEarly(node);				//set visited flag				status[node] |= VISITED;					if(node.hasEdges()) {					edges = graph.getEdgesFrom(node);					iterator = edges.iterator();					//for all edges					while(iterator.hasNext()) {						edge = iterator.next() as GraphEdge;						nextNode = edge.getNode();							//if not visited yet, also visit the edge						//TODO, do we want to visit all edges, or only this subselection?						if((status[nextNode] & VISITED) == 0) {							visitor.visitEdge(edge);							}						//if not discovered yet						if((status[nextNode] & DISCOVERED) == 0) {							//visit this node sometime in the future							queue.enqueue(nextNode);							//update disvovered flag							status[nextNode] |= DISCOVERED;								//update the parent reference for the shortest path part							parents[nextNode] = node;						}					}				}				visitor.visitNodeLate(node);			}		}		/**		 * gets the shortest path to the specified node from the node passed in via the constructor.		 * this shortest path is only valid for undirected graphs		 * The shortest path will <em>not</em> take the weight of the edges in account. For that, use dijkstra's algorithm.		 * @param to the node we want the path to		 * @return a List of GraphNodes excluding the final node. an empty list if there is no path.		 */		public function getShortestPath(to : GraphNode) : List {			var list : List = new LinkedList();			var node : GraphNode = to;			var parent : GraphNode = parents[node];			while(parent != null) {				list.addFirst(parent);				parent = parents[parent];				}			return list;		}								/**		 * prepares the stuff used in processing		 */		private function prepare(graph : Graph) : void {			parents = new Dictionary(true);			status = new Dictionary(true);			var iterator : IIterator = graph.iterator();			var node : GraphNode;			while(iterator.hasNext()) {				node = iterator.next() as GraphNode;				//the next line really does not seem necessary, which means this whole method does not have to loop over all nodes				//apparently the bitwise operations can function with null values too.				status[node] = BLANK;			}		}				/**		 * destroys all stuff		 */		public function destroy() : void {			status = null;			parents = null;			graph = null;		}	}}