/*Copyright (c) 2009 De Pannekoek en De Kale B.V.,  www.dpdk.nlPermission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the "Software"), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included inall copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS INTHE SOFTWARE. */package nl.dpdk.commands.tasks {	import nl.dpdk.collections.iteration.IIterator;	import nl.dpdk.collections.lists.ArrayList;	import nl.dpdk.collections.lists.List;	import nl.dpdk.commands.ICommand;	import flash.events.EventDispatcher;	/**	 * Sequence is a manager for multiple tasks that need to be executed serially.	 * It should be used as a sequence manager, and can hold instances of subclasses of Task.	 * When a sequence runs, it discards it's tasks. 	 * We are assuming you only want to run a sequence once.	 * To have a sequence loop over and over, use a method to (re)build the sequence and execute it (again in the event handler for when the sequence is done).	 * 	 * 	 * Complex nested sequences can be formed by using SequenceTask.	 * Different groups of blocking/nonblocking sequences can be put inside tasks. 	 * These tasks can then be put in one sequence that will execute them as a whole.	 * As an example, consider the case where some assets should be loaded by different tasks, but when this fails, it is not critical for the application as a whole.	 * Those tasks can be put in a sequence that does not abort when an error occurs and that sequence will be put in a SequenceTask. 	 * At the same time, some assets are essential to be loaded, as some other stuff might depend on them. Those assets loading tasks can be put in a different Sequence that does abort inside a SequenceTask.	 * To have the safety that the noncritical tasks do not prevent the critical tasks to be executed when the noncritical fail,	 * and to have the safety that critical tasks will fail the whole process, we will use both SequenceTasks	 * Both SequenceTasks can now be put in a Sequence that will fail on Error and we have achieved our goal of fine grained, nested and complex flow control.	 * example:	<code>	//should fail when something goes wrong	var crucial: Sequence = new Sequence(true);	crucial.add(new LoaderTask("veryImportant.swf");	crucial.add(new LoaderTask("weNeedThis.swf");	crucial.add(new VeryComplexTask());	crucial.add(new LoaderTask("andThisToo.swf");		//when something goes wrong, we don't mind	var optional: Sequence = new Sequence(false);	optional.add(new LoaderTask("unimportant.swf");	optional.add(new LoaderTask("boringStuff.swf");		//now, put those sequences in a SequenceTask	var crucialTask: Task = new SequenceTask(crucial);	var optionalTask: Task = new SequenceTask(optional);		//create the master sequence that should fail when something important fails	var master: Sequence = new Sequence(true);	master.add(new PreloaderTask());	master.add(new optionalTask());	master.add(new crucialTask());	//now start executing the tasks!	master.addEventListener(SequenceEvent.ERROR, onError);	master.addEventListener(SequenceEvent.DONE, onDone);	master.execute();		//when unimportant.swf fails to load, the rest of the tasks and sequences will continue and eventually, onDone will be called	//when weNeedThis.swf fails to load, onError will be triggered and the rest of the stuff will not be handled.	 	</code>	 * 	 * 	 * 	 * 	 * @see nl.dpdk.commands.tasks.Task	 * @see nl.dpdk.commands.tasks.SequenceTask	 * @author Rolf Vreijdenberger, Thomas Brekelmans, Oskar van Velden	 	 */	 	/**	 * Error event from a Sequence. The error message can be retrieved from the event.	 * This event occurs when a Sequence finishes with an Error, which it does when it should abortOnError. 	 * The DONE event is not dispatched when ERROR is dispatched. 	 * The NEXT event is not dispatched when ERROR is dispatched.	 * 	 * Whenever a nonblocking error occurs, the sequence will just continue.	 * for nonblocking error detection use the ERROR_NON_BLOCKING event type	 */	[Event(name="ERROR", type="nl.dpdk.commands.tasks.SequenceEvent")]	/**	 * Error event from a Task that should not abort on error. The error message can be retrieved from the event.	 * a client can listen to this event from a specific subclass, 	 * to have more fine grained control over where exactly the error happened.	 * Whenever a nonblocking error occurs, the sequence will just continue executing.	 * This event is dispatched just before trying to execute a possible next task in the sequence, and therefore just before the NEXT event might be called.	 */	[Event(name="ERROR_NON_BLOCKING", type="nl.dpdk.commands.tasks.SequenceEvent")]	/**	 * When a Sequence has totally finished executing all it's tasks, it's DONE event is dispatched	 */	[Event(name="DONE", type="nl.dpdk.commands.tasks.SequenceEvent")]	/**	 * When a Sequence begins, it's START event type is dispatched.	 * this event is not called on sequence.resume(), only on sequence.execute().	 */	[Event(name="START", type="nl.dpdk.commands.tasks.SequenceEvent")]	/**	 * When a SequenceEvent has multipe tasks, it's NEXT event type is dispatched for each task just before the sequence tries to go to the next task.	 * This might be used as a hook to use an interrupt on a task.	 * sequence.getCurrent() will return the task that has just finished executing, the SequenceEvent.getTask() will hold the task that will be executed next.	 * sequence.setPaused() might be called in the event handler for this event type and the next task will not be executed then.	 * If you do that, beware of a loop in which you call sequence.resume() after thatwhich will fire the event again, which will make the sequence pause etc ad infinitum.	 * If you want a pause/resume functionality, just use a CallBackTask(sequence.pause) after the task after you wish to pause.	 * This event is very powerful to manipulate the data in a Task that has just executed, since the task.destroy() method has not yet been called and all data is still intact in the task.	 * IMPORTANT: the event itself contains the task that has just executed with the task.destroy() method not yet called. 	 * IMPORTANT: the sequence.getCurrent() method contains the Task that has just finished executing with the task.destroy() method not yet called!	 * IMPORTANT: this event will not fire for the first task that executes. SequenceEvent.START is used for that.	 * IMPORTANT: this event will also fire just before SequenceEvent.DONE to give the client the means to manipulate the final executed task in the Sequence via sequence.getCurrent().	 * IMPORTANT: the real 'next' task that will be executed can be retrieved from sequence.getTasks().get(0);	 */	[Event(name="NEXT", type="nl.dpdk.commands.tasks.SequenceEvent")]	public final class Sequence extends EventDispatcher implements ICommand {		//holds the tasks in a list		private var tasks : ArrayList = new ArrayList();		//flag if we should abort executing the sequence if an error occurs in a task		private var abortOnError : Boolean = false;		//flag to see if the sequence is executing at the moment		private var executing : Boolean = false;		//is the sequence paused or not?		private var paused : Boolean = false;		//the currently executing task		private var current : Task;		//flag variable to check whether the first task has executed		private var firstTask : Boolean = true;				/**		 * Subclasses of Task can have context passed in via their constructor (references to other objects, or other kinds of data).		 * These subclasses can also be listened to for specific events outside of the sequence, and can have a fatter interface than their superclasses (to retrieve context for example, or to query the state of the task).		 * 		 * @param abortOnError a flag if a whole task sequence should stop executing if an error occurs in a task.		 */		public function Sequence(abortOnError : Boolean = false) {			this.abortOnError = abortOnError;		}		/**		 * @param task the Task to add to the sequence of tasks to execute		 */		public final function add(task : Task) : void {			if(tasks){				tasks.add(task);			}		}		/**		 * @param task the Task to remove from the sequence of tasks to execute		 */		public final function remove(task : Task) : Boolean {			return tasks ? tasks.remove(task) : false;		}								/**		 * the method that starts it all. Call this method once to start the execution of the sequence and it's tasks.		 * In order to be able to use the Sequence in an environment that supports Commands, the ICommand interface has been implemented.		 * Whenever a sequence of commands is being executed, calling this method again will produce no result.		 */		public final function execute() : void {			if(isExecuting()) {				trace("Sequence has already started");			} else {				//set a flag				setExecuting(true);				//dispatch an event for when the sequence starts				dispatchEvent(new SequenceEvent(SequenceEvent.START, null, "Sequence has started"));				tryNextTask();			}		}						/**		 * what is the size of the sequence.		 * The (remaining) tasks in the sequence.		 */		public final function size() : uint {			return tasks ? tasks.size() : 0;		}		/**		 * check if this sequence contains a specific task.		 */		public final function contains(task : Task) : Boolean {			return tasks ? tasks.contains(task) : false;		}				private function setExecuting(boolean : Boolean) : void {			executing = boolean;		}		/**		 * is this Task currently executing it's task or it's subtasks?		 */		public final function isExecuting() : Boolean {			return executing;		}						/**		 * the sequence handler.		 */		private function executeNextTask() : void {			//this check is a little redundant, as we are checking this in tryNextTask also, but there is an edge case, see the else statement.			if(!getPaused() && tasks && tasks.size() != 0) {				//remove the task from the list				var task : Task = tasks.dequeue() as Task;				task.addEventListener(TaskEvent.DONE, onDone, false, -1);				task.addEventListener(TaskEvent.ERROR, onError, false, -1);				if(getCurrent()) {					//first time around, getCurrent is null.					//now, destroy the task. we destroy the task here, because the data inside the task can be manipulated/retrieved by the client in the event handler for SequenceEvent.NEXT					getCurrent().destroy();				}				setCurrent(task);				//now, execute the task!				task.execute();			} else{				//this might happen if someone directly manipulated the tasks list from outside of this class by clearing the whole thing in the NEXT event handler,				//or when pausing from the NEXT event handler.				//edge case that is very unlikely, no need to fix this, I assume you know what you are doing then as those are power functionalities.				//trace(toString() + ".executeNextTask(): whoops, there is nothing to be done here... but someone is calling us....did you pause me?");			}		}		private function setCurrent(task : Task) : void {			current = task;		}		private function finished() : void {			setExecuting(false);			dispatchEvent(new SequenceEvent(SequenceEvent.DONE, null, "all tasks finished"));			//TODO, think about internal cleanup with destroy()		}		/**		 * is the sequence paused or not?		 */		public function getPaused() : Boolean {			return paused;		}		/**		 * pause the sequence flow (not the currently executing task).		 * use resume() to continue the flow.		 */		public function pause() : void {			setPaused(true);		}		private function setPaused(paused : Boolean) : void {			this.paused = paused;		}		public function resume() : void {			setPaused(false);			tryNextTask();		}				/**		 * TaskEvent handler for errors.		 */		private function onError(event : TaskEvent) : void {			var task : Task = event.getTask();			task.removeEventListener(TaskEvent.DONE, onDone);			task.removeEventListener(TaskEvent.ERROR, onError);			var message : String = event.getMessage();			if( abortOnError ) {				//arghhhh, stop right now!!!				setExecuting(false);				dispatchEvent(new SequenceEvent(SequenceEvent.ERROR, task, message));				//destroy the task here.. this means we can get data from the task via the previous event dispatched before destroying the task				task.destroy();			} else {				dispatchEvent(new SequenceEvent(SequenceEvent.ERROR_NON_BLOCKING, task, message));				//well, an error is not nice, but just continue execution of the sequence.				tryNextTask();						}		}		/**		 * this checks the right conditions for a task to be executed		 * while there are tasks and we are not paused, execute them, else we are totally done!		 */		private function tryNextTask() : void {						//when we are paused, just stop...			if(!getPaused()) {				//check if there are tasks to execute				if(tasks.size() != 0) {					//check if this is the first task					if(firstTask){						firstTask = false;					}else{							//no, this is not the first task.							//feed the event with the next task we will execute							//dispatch an event. the SequenceEvent.NEXT event might be used to manipulate the task or the sequence							//or to get data from the task in the event listener							dispatchEvent(new SequenceEvent(SequenceEvent.NEXT, getCurrent()));					}					executeNextTask();				} else {					//no tasks left, dispatch final next event to give the client a change to access the latest executed task in the event handler by calling sequence.getCurrent()					dispatchEvent(new SequenceEvent(SequenceEvent.NEXT, null));					if(getCurrent()) {						//null check for the edge case when we try to execute a Sequence that was never filled.						getCurrent().destroy();					}					//we're done					finished();				}			}		}		/**		 * TaskEvent handler for when a task is done.		 * These events come from tasks that have been added to the present task in a sequence.		 */		private function onDone(event : TaskEvent) : void {				var task : Task = event.getTask();			task.removeEventListener(TaskEvent.DONE, onDone);			task.removeEventListener(TaskEvent.ERROR, onError);			tryNextTask();		}								/**		 * cleans up this sequence.		 */		public function destroy() : void {			try {				var task : Task;				var iterator : IIterator = tasks.iterator();				while (iterator.hasNext()) {					task = iterator.next() as Task;					try {						iterator.remove();						//TODO, think about when this might cause a runtime error..						//can you remove non-existent event listeners?						task.removeEventListener(TaskEvent.DONE, onDone);						task.removeEventListener(TaskEvent.ERROR, onError);						task.destroy();					}catch(e : Error) {						trace("Error in Task.clear() when doing cleanup: " + e.message);					}				}				tasks.clear();			}catch(e : Error) {				trace("Error in Sequence.clear(): " + e.message);			}		}				override public function toString() : String {			return "Sequence";		}		/**		 * the currently executing task, or the task that has finished executing as the SequenceEvent.NEXT event is dispatched.		 */		public function getCurrent() : Task {			return current;		}		/**		 * A List of the tasks remaining in this sequence to be executed.		 * A client can and may directly manipulate this list of Task items, but will lose type safety.		 * While a client should normally not wish to manipulate this list directly, it might be convenient for power users.		 * This method will probably be used when listening to the SequenceEvent.NEXT event.		 */		public function getTasks() : List {			return tasks;		}	}}